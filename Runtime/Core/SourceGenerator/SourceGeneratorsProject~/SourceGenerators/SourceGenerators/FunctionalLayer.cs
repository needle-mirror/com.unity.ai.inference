using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerators
{
    public static class FunctionalLayer
    {
        public static void GenerateFunctionalLayer(SourceProductionContext spc, ImmutableArray<INamedTypeSymbol> classSymbols)
        {
            // TODO fix hack to prevent multiple model loader classes being created in different assemblies
            if (classSymbols[0].ContainingNamespace.ToString() != "Unity.InferenceEngine.Layers")
                return;

            MemoryStream sourceStream = new();
            StreamWriter sourceStreamWriter = new(sourceStream, Encoding.UTF8);
            IndentedTextWriter codeWriter = new(sourceStreamWriter);

            codeWriter.WriteLine("// <auto-generated/>");
            codeWriter.WriteLine("using Unity.InferenceEngine.Layers;");
            codeWriter.WriteLine("using Unity.InferenceEngine.Graph;");
            codeWriter.WriteLine("using System.Linq;");
            codeWriter.WriteLine();
            codeWriter.WriteLine("namespace Unity.InferenceEngine");
            codeWriter.WriteLine('{');
            codeWriter.Indent++;
            codeWriter.WriteLine("internal static class FunctionalLayer");
            codeWriter.WriteLine('{');
            codeWriter.Indent++;

            codeWriter.WriteLine("public static object InferPartial(string target, Argument[] args)");
            codeWriter.WriteLine('{');
            codeWriter.Indent++;

            for (var i = 0; i < classSymbols.Length; i++)
            {
                var classSymbol = classSymbols[i];
                var opDef = new OpDef(classSymbol);
                codeWriter.WriteLine($"if (target == \"{opDef.m_Name}\")");
                codeWriter.WriteLine('{');
                codeWriter.Indent++;

                int numInputs;
                var argNames = new List<string>();
                if (opDef.m_IsInputsVariadic)
                {
                    numInputs = 1;
                    argNames.Add("inputPartialTensors");
                    codeWriter.WriteLine("var inputPartialTensors = args[0].AsNodeArray.Select(n => n?.partialTensor).ToArray();");
                }
                else
                {
                    numInputs = opDef.m_Inputs.Length;
                    for (var j = 0; j < opDef.m_Inputs.Length; j++)
                    {
                        argNames.Add(opDef.m_Inputs[j].name);
                        codeWriter.WriteLine($"var {opDef.m_Inputs[j].name} = ((Node)args[{j}])?.partialTensor;");
                    }
                }
                for (var j = 0; j < opDef.m_Fields.Length; j++)
                {
                    var field = opDef.m_Fields[j];
                    argNames.Add(field.name);
                    codeWriter.WriteLine($"var {field.name} = ({field.type.Signature()})args[{numInputs + j}];");
                }

                codeWriter.WriteLine($"return Layers.{opDef.m_Name}.InferPartial({string.Join(", ", argNames.ToArray())});");

                codeWriter.Indent--;
                codeWriter.WriteLine('}');
            }

            codeWriter.WriteLine("return null;");
            codeWriter.Indent--;
            codeWriter.WriteLine('}');
            codeWriter.WriteLine();

            for (var i = 0; i < classSymbols.Length; i++)
            {
                var classSymbol = classSymbols[i];
                var opDef = new OpDef(classSymbol);
                codeWriter.Write("public static FunctionalTensor");
                if (opDef.m_IsOutputsVariadic || opDef.m_Outputs.Length > 1)
                    codeWriter.Write("[]");
                codeWriter.Write($" {classSymbol.Name}(");
                var isFirst = true;
                if (opDef.m_IsInputsVariadic)
                {
                    codeWriter.Write("FunctionalTensor[] inputs");
                    isFirst = false;
                }
                else
                {
                    foreach (var input in opDef.m_Inputs)
                    {
                        if (!isFirst)
                            codeWriter.Write(", ");
                        codeWriter.Write($"FunctionalTensor {input.name}");
                        isFirst = false;
                    }
                }
                foreach (var field in opDef.m_Fields)
                {
                    if (!isFirst)
                        codeWriter.Write(", ");
                    codeWriter.Write($"{field.type.Signature()} {field.name}");
                    isFirst = false;
                }
                codeWriter.WriteLine(')');
                codeWriter.WriteLine('{');
                codeWriter.Indent++;
                codeWriter.Write($"return Functional.FromLayer(\"{classSymbol.Name}\", new Argument[] {{ ");
                isFirst = true;
                if (opDef.m_IsInputsVariadic)
                {
                    codeWriter.Write("inputs");
                    isFirst = false;
                }
                else
                {
                    foreach (var input in opDef.m_Inputs)
                    {
                        if (!isFirst)
                            codeWriter.Write(", ");
                        codeWriter.Write($"{input.name}");
                        isFirst = false;
                    }
                }
                foreach (var field in opDef.m_Fields)
                {
                    if (!isFirst)
                        codeWriter.Write(", ");
                    codeWriter.Write($"{field.name}");
                    isFirst = false;
                }
                codeWriter.Write(" })");
                if (!opDef.m_IsOutputsVariadic && opDef.m_Outputs.Length <= 1)
                    codeWriter.Write("[0]");
                codeWriter.WriteLine(";");
                codeWriter.Indent--;
                codeWriter.WriteLine('}');
                codeWriter.WriteLine();
            }

            codeWriter.Indent--;
            codeWriter.WriteLine('}');
            codeWriter.Indent--;
            codeWriter.WriteLine('}');
            codeWriter.WriteLine();

            sourceStreamWriter.Flush();
            spc.AddSource("FunctionalLayer.g.cs", SourceText.From(sourceStream, Encoding.UTF8, canBeEmbedded: true));
        }
    }
}
