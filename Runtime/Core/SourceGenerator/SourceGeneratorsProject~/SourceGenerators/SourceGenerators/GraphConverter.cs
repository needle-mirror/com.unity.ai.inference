using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerators
{
    public static class GraphConverter
    {
        public static void GenerateGraphConverter(SourceProductionContext spc, ImmutableArray<INamedTypeSymbol> classSymbols)
        {
            // TODO fix hack to prevent multiple model loader classes being created in different assemblies
            if (classSymbols[0].ContainingNamespace.ToString() != "Unity.InferenceEngine.Layers")
                return;

            MemoryStream sourceStream = new();
            StreamWriter sourceStreamWriter = new(sourceStream, Encoding.UTF8);
            IndentedTextWriter codeWriter = new(sourceStreamWriter);

            codeWriter.WriteLine("// <auto-generated/>");
            codeWriter.WriteLine("using Unity.InferenceEngine.Layers;");
            codeWriter.WriteLine();
            codeWriter.WriteLine("namespace Unity.InferenceEngine.Graph");
            codeWriter.WriteLine('{');
            codeWriter.Indent++;

            codeWriter.WriteLine("static partial class GraphModuleExtensions");
            codeWriter.WriteLine('{');
            codeWriter.Indent++;
            for (var i = 0; i < classSymbols.Length; i++)
            {
                var classSymbol = classSymbols[i];
                var opDef = new OpDef(classSymbol);
                var isOutputList = opDef.m_IsOutputsVariadic || opDef.m_Outputs?.Length > 1;
                codeWriter.Write(isOutputList ? "public static Node[]" : "public static Node");
                codeWriter.Write($" {opDef.m_Name}(this GraphModule gm");
                var argsPartialTensor = new List<string>();
                var args = new List<string>();

                if (opDef.m_IsInputsVariadic)
                {
                    codeWriter.Write(", Node[] inputs");
                    args.Add("new Argument(inputs)");
                    argsPartialTensor.Add("inputPartialTensors");
                }
                else
                {
                    for (var j = 0; j < opDef.m_Inputs.Length; j++)
                    {
                        codeWriter.Write($", Node {opDef.m_Inputs[j].name}");
                        args.Add(opDef.m_Inputs[j].name);
                        argsPartialTensor.Add($"{opDef.m_Inputs[j].name}?.partialTensor");
                    }
                }
                for (var j = 0; j < opDef.m_Fields.Length; j++)
                {
                    var field = opDef.m_Fields[j];
                    codeWriter.Write($", {field.type.Signature()} {field.name}");
                    args.Add(field.name);
                    argsPartialTensor.Add(opDef.m_Fields[j].name);
                }
                codeWriter.WriteLine(")");
                codeWriter.WriteLine("{");
                codeWriter.Indent++;
                if (opDef.m_IsInputsVariadic)
                {
                    codeWriter.WriteLine("var inputPartialTensors = new PartialTensor[inputs.Length];");
                    codeWriter.WriteLine("for (var i = 0; i < inputs.Length; i++)");
                    codeWriter.WriteLine("    inputPartialTensors[i] = inputs[i]?.partialTensor;");
                }
                if (isOutputList)
                {
                    codeWriter.WriteLine($"var partialTensors = Layers.{opDef.m_Name}.InferPartial({string.Join(", ", argsPartialTensor)});");
                    codeWriter.WriteLine($"var layerNode = gm.graph.CallFunction(\"{opDef.m_Name}\", new Argument[] {{ {string.Join(", ", args)} }});");
                    if (opDef.m_IsOutputsVariadic)
                        codeWriter.WriteLine("var indexerNodes = new Node[numOutputs];");
                    else
                        codeWriter.WriteLine($"var indexerNodes = new Node[{opDef.m_Outputs.Length}];");
                    codeWriter.WriteLine("for (var i = 0; i < indexerNodes.Length; i++)");
                    codeWriter.WriteLine("{");
                    codeWriter.Indent++;
                    codeWriter.WriteLine("indexerNodes[i] = gm.graph.CallFunction(\"getitem\", new Argument[] { layerNode, i });");
                    codeWriter.WriteLine("indexerNodes[i].partialTensor = partialTensors[i];");
                    codeWriter.Indent--;
                    codeWriter.WriteLine("}");
                    codeWriter.WriteLine("return indexerNodes;");
                }
                else
                {
                    codeWriter.WriteLine($"var partialTensor = Layers.{opDef.m_Name}.InferPartial({string.Join(", ", argsPartialTensor)});");
                    codeWriter.WriteLine($"var layerNode = gm.graph.CallFunction(\"{opDef.m_Name}\", new Argument[] {{ {string.Join(", ", args)} }});");
                    codeWriter.WriteLine("layerNode.partialTensor = partialTensor;");
                    codeWriter.WriteLine("return layerNode;");
                }
                codeWriter.Indent--;
                codeWriter.WriteLine("}");
            }

            codeWriter.Indent--;
            codeWriter.WriteLine('}');
            codeWriter.WriteLine("static partial class GraphConverter");
            codeWriter.WriteLine('{');
            codeWriter.Indent++;
            codeWriter.WriteLine("public static Argument[] LayerToArgs(Layer layer, Node[] inputs)");
            codeWriter.WriteLine('{');
            codeWriter.Indent++;
            for (var i = 0; i < classSymbols.Length; i++)
            {
                var classSymbol = classSymbols[i];
                var opDef = new OpDef(classSymbol);
                codeWriter.WriteLine($"if (layer is {classSymbol.Name} layer{classSymbol.Name})");
                codeWriter.WriteLine('{');
                codeWriter.Indent++;
                var isFirst = true;
                codeWriter.Write("return new Argument[] { ");

                if (opDef.m_IsInputsVariadic)
                {
                    codeWriter.Write("inputs");
                    isFirst = false;
                }
                else
                {
                    for (var j = 0; j < opDef.m_Inputs.Length; j++)
                    {
                        if (!isFirst)
                            codeWriter.Write(", ");
                        codeWriter.Write($"inputs[{j}]");
                        isFirst = false;
                    }
                }
                foreach (var field in opDef.m_Fields)
                {
                    if (!isFirst)
                        codeWriter.Write(", ");
                    codeWriter.Write($"layer{classSymbol.Name}.{field.name}");
                    isFirst = false;
                }
                codeWriter.WriteLine(" };");
                codeWriter.Indent--;
                codeWriter.WriteLine('}');
            }

            codeWriter.WriteLine("return null;");

            codeWriter.Indent--;
            codeWriter.WriteLine('}');
            codeWriter.WriteLine();

            codeWriter.WriteLine("public static Layer NodeToLayer(Node node, System.Func<Node, int> getIndex)");
            codeWriter.WriteLine('{');
            codeWriter.Indent++;
            for (var i = 0; i < classSymbols.Length; i++)
            {
                var classSymbol = classSymbols[i];
                var opDef = new OpDef(classSymbol);
                var numInputs = opDef.m_IsInputsVariadic ? 1 : opDef.m_Inputs.Length;
                codeWriter.WriteLine($"if (node.target == \"{classSymbol.Name}\")");
                codeWriter.WriteLine("{");
                codeWriter.Indent++;
                codeWriter.Write($"var layer = new {opDef.m_Name}(");
                var isFirst = true;
                for (var j = 0; j < opDef.m_Fields.Length; j++)
                {
                    var field = opDef.m_Fields[j];
                    if (!isFirst)
                        codeWriter.Write(", ");
                    codeWriter.Write($"({field.type.Signature()})node.args[{numInputs + j}]");
                    isFirst = false;
                }

                codeWriter.WriteLine(");");
                if (opDef.m_IsInputsVariadic)
                {
                    codeWriter.WriteLine("var inputArgs = node.args[0].AsNodeArray;");
                    codeWriter.WriteLine("var inputs = new int[inputArgs.Length];");
                    codeWriter.WriteLine("for (var i = 0; i < inputs.Length; i++)");
                    codeWriter.Indent++;
                    codeWriter.WriteLine("inputs[i] = getIndex(inputArgs[i]);");
                    codeWriter.Indent--;
                    codeWriter.WriteLine("layer.SetInputs(inputs);");
                }
                else
                {
                    codeWriter.Write("layer.SetInputs(");
                    isFirst = true;
                    for (var j = 0; j < opDef.m_Inputs.Length; j++)
                    {
                        if (!isFirst)
                            codeWriter.Write(", ");
                        codeWriter.Write($"getIndex((Node)node.args[{j}])");
                        isFirst = false;
                    }

                    codeWriter.WriteLine(");");
                }

                codeWriter.WriteLine("return layer;");
                codeWriter.Indent--;
                codeWriter.WriteLine("}");
            }

            codeWriter.WriteLine("return null;");

            codeWriter.Indent--;
            codeWriter.WriteLine('}');

            codeWriter.Indent--;
            codeWriter.WriteLine('}');
            codeWriter.Indent--;
            codeWriter.WriteLine('}');
            codeWriter.WriteLine();

            sourceStreamWriter.Flush();
            spc.AddSource("GraphConverter.g.cs", SourceText.From(sourceStream, Encoding.UTF8, canBeEmbedded: true));
        }
    }
}
