// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>
#define ENABLE_SPAN_T
#define UNSAFE_BYTEBUFFER
#define BYTEBUFFER_NO_BOUNDS_CHECK

namespace Unity.InferenceEngine.Editor.LiteRT
{

using global::System;
using global::System.Collections.Generic;
using global::Unity.InferenceEngine.Google.FlatBuffers;

enum TensorType : sbyte
{
  FLOAT32 = 0,
  FLOAT16 = 1,
  INT32 = 2,
  UINT8 = 3,
  INT64 = 4,
  STRING = 5,
  BOOL = 6,
  INT16 = 7,
  COMPLEX64 = 8,
  INT8 = 9,
  FLOAT64 = 10,
  COMPLEX128 = 11,
  UINT64 = 12,
  RESOURCE = 13,
  VARIANT = 14,
  UINT32 = 15,
  UINT16 = 16,
  INT4 = 17,
  BFLOAT16 = 18,
};

enum QuantizationDetails : byte
{
  NONE = 0,
  CustomQuantization = 1,
  BlockwiseQuantization = 2,
};

enum DimensionType : sbyte
{
  DENSE = 0,
  SPARSE_CSR = 1,
};

enum SparseIndexVector : byte
{
  NONE = 0,
  Int32Vector = 1,
  Uint16Vector = 2,
  Uint8Vector = 3,
};

enum BuiltinOperator : int
{
  ADD = 0,
  AVERAGE_POOL_2D = 1,
  CONCATENATION = 2,
  CONV_2D = 3,
  DEPTHWISE_CONV_2D = 4,
  DEPTH_TO_SPACE = 5,
  DEQUANTIZE = 6,
  EMBEDDING_LOOKUP = 7,
  FLOOR = 8,
  FULLY_CONNECTED = 9,
  HASHTABLE_LOOKUP = 10,
  L2_NORMALIZATION = 11,
  L2_POOL_2D = 12,
  LOCAL_RESPONSE_NORMALIZATION = 13,
  LOGISTIC = 14,
  LSH_PROJECTION = 15,
  LSTM = 16,
  MAX_POOL_2D = 17,
  MUL = 18,
  RELU = 19,
  RELU_N1_TO_1 = 20,
  RELU6 = 21,
  RESHAPE = 22,
  RESIZE_BILINEAR = 23,
  RNN = 24,
  SOFTMAX = 25,
  SPACE_TO_DEPTH = 26,
  SVDF = 27,
  TANH = 28,
  CONCAT_EMBEDDINGS = 29,
  SKIP_GRAM = 30,
  CALL = 31,
  CUSTOM = 32,
  EMBEDDING_LOOKUP_SPARSE = 33,
  PAD = 34,
  UNIDIRECTIONAL_SEQUENCE_RNN = 35,
  GATHER = 36,
  BATCH_TO_SPACE_ND = 37,
  SPACE_TO_BATCH_ND = 38,
  TRANSPOSE = 39,
  MEAN = 40,
  SUB = 41,
  DIV = 42,
  SQUEEZE = 43,
  UNIDIRECTIONAL_SEQUENCE_LSTM = 44,
  STRIDED_SLICE = 45,
  BIDIRECTIONAL_SEQUENCE_RNN = 46,
  EXP = 47,
  TOPK_V2 = 48,
  SPLIT = 49,
  LOG_SOFTMAX = 50,
  DELEGATE = 51,
  BIDIRECTIONAL_SEQUENCE_LSTM = 52,
  CAST = 53,
  PRELU = 54,
  MAXIMUM = 55,
  ARG_MAX = 56,
  MINIMUM = 57,
  LESS = 58,
  NEG = 59,
  PADV2 = 60,
  GREATER = 61,
  GREATER_EQUAL = 62,
  LESS_EQUAL = 63,
  SELECT = 64,
  SLICE = 65,
  SIN = 66,
  TRANSPOSE_CONV = 67,
  SPARSE_TO_DENSE = 68,
  TILE = 69,
  EXPAND_DIMS = 70,
  EQUAL = 71,
  NOT_EQUAL = 72,
  LOG = 73,
  SUM = 74,
  SQRT = 75,
  RSQRT = 76,
  SHAPE = 77,
  POW = 78,
  ARG_MIN = 79,
  FAKE_QUANT = 80,
  REDUCE_PROD = 81,
  REDUCE_MAX = 82,
  PACK = 83,
  LOGICAL_OR = 84,
  ONE_HOT = 85,
  LOGICAL_AND = 86,
  LOGICAL_NOT = 87,
  UNPACK = 88,
  REDUCE_MIN = 89,
  FLOOR_DIV = 90,
  REDUCE_ANY = 91,
  SQUARE = 92,
  ZEROS_LIKE = 93,
  FILL = 94,
  FLOOR_MOD = 95,
  RANGE = 96,
  RESIZE_NEAREST_NEIGHBOR = 97,
  LEAKY_RELU = 98,
  SQUARED_DIFFERENCE = 99,
  MIRROR_PAD = 100,
  ABS = 101,
  SPLIT_V = 102,
  UNIQUE = 103,
  CEIL = 104,
  REVERSE_V2 = 105,
  ADD_N = 106,
  GATHER_ND = 107,
  COS = 108,
  WHERE = 109,
  RANK = 110,
  ELU = 111,
  REVERSE_SEQUENCE = 112,
  MATRIX_DIAG = 113,
  QUANTIZE = 114,
  MATRIX_SET_DIAG = 115,
  ROUND = 116,
  HARD_SWISH = 117,
  IF = 118,
  WHILE = 119,
  NON_MAX_SUPPRESSION_V4 = 120,
  NON_MAX_SUPPRESSION_V5 = 121,
  SCATTER_ND = 122,
  SELECT_V2 = 123,
  DENSIFY = 124,
  SEGMENT_SUM = 125,
  BATCH_MATMUL = 126,
  PLACEHOLDER_FOR_GREATER_OP_CODES = 127,
  CUMSUM = 128,
  CALL_ONCE = 129,
  BROADCAST_TO = 130,
  RFFT2D = 131,
  CONV_3D = 132,
  IMAG = 133,
  REAL = 134,
  COMPLEX_ABS = 135,
  HASHTABLE = 136,
  HASHTABLE_FIND = 137,
  HASHTABLE_IMPORT = 138,
  HASHTABLE_SIZE = 139,
  REDUCE_ALL = 140,
  CONV_3D_TRANSPOSE = 141,
  VAR_HANDLE = 142,
  READ_VARIABLE = 143,
  ASSIGN_VARIABLE = 144,
  BROADCAST_ARGS = 145,
  RANDOM_STANDARD_NORMAL = 146,
  BUCKETIZE = 147,
  RANDOM_UNIFORM = 148,
  MULTINOMIAL = 149,
  GELU = 150,
  DYNAMIC_UPDATE_SLICE = 151,
  RELU_0_TO_1 = 152,
  UNSORTED_SEGMENT_PROD = 153,
  UNSORTED_SEGMENT_MAX = 154,
  UNSORTED_SEGMENT_SUM = 155,
  ATAN2 = 156,
  UNSORTED_SEGMENT_MIN = 157,
  SIGN = 158,
  BITCAST = 159,
  BITWISE_XOR = 160,
  RIGHT_SHIFT = 161,
  STABLEHLO_LOGISTIC = 162,
  STABLEHLO_ADD = 163,
  STABLEHLO_DIVIDE = 164,
  STABLEHLO_MULTIPLY = 165,
  STABLEHLO_MAXIMUM = 166,
  STABLEHLO_RESHAPE = 167,
  STABLEHLO_CLAMP = 168,
  STABLEHLO_CONCATENATE = 169,
  STABLEHLO_BROADCAST_IN_DIM = 170,
  STABLEHLO_CONVOLUTION = 171,
  STABLEHLO_SLICE = 172,
  STABLEHLO_CUSTOM_CALL = 173,
  STABLEHLO_REDUCE = 174,
  STABLEHLO_ABS = 175,
  STABLEHLO_AND = 176,
  STABLEHLO_COSINE = 177,
  STABLEHLO_EXPONENTIAL = 178,
  STABLEHLO_FLOOR = 179,
  STABLEHLO_LOG = 180,
  STABLEHLO_MINIMUM = 181,
  STABLEHLO_NEGATE = 182,
  STABLEHLO_OR = 183,
  STABLEHLO_POWER = 184,
  STABLEHLO_REMAINDER = 185,
  STABLEHLO_RSQRT = 186,
  STABLEHLO_SELECT = 187,
  STABLEHLO_SUBTRACT = 188,
  STABLEHLO_TANH = 189,
  STABLEHLO_SCATTER = 190,
  STABLEHLO_COMPARE = 191,
  STABLEHLO_CONVERT = 192,
  STABLEHLO_DYNAMIC_SLICE = 193,
  STABLEHLO_DYNAMIC_UPDATE_SLICE = 194,
  STABLEHLO_PAD = 195,
  STABLEHLO_IOTA = 196,
  STABLEHLO_DOT_GENERAL = 197,
  STABLEHLO_REDUCE_WINDOW = 198,
  STABLEHLO_SORT = 199,
  STABLEHLO_WHILE = 200,
  STABLEHLO_GATHER = 201,
  STABLEHLO_TRANSPOSE = 202,
  DILATE = 203,
  STABLEHLO_RNG_BIT_GENERATOR = 204,
  REDUCE_WINDOW = 205,
  STABLEHLO_COMPOSITE = 206,
  STABLEHLO_SHIFT_LEFT = 207,
  STABLEHLO_CBRT = 208,
  STABLEHLO_CASE = 209,
};

enum BuiltinOptions : byte
{
  NONE = 0,
  Conv2DOptions = 1,
  DepthwiseConv2DOptions = 2,
  ConcatEmbeddingsOptions = 3,
  LSHProjectionOptions = 4,
  Pool2DOptions = 5,
  SVDFOptions = 6,
  RNNOptions = 7,
  FullyConnectedOptions = 8,
  SoftmaxOptions = 9,
  ConcatenationOptions = 10,
  AddOptions = 11,
  L2NormOptions = 12,
  LocalResponseNormalizationOptions = 13,
  LSTMOptions = 14,
  ResizeBilinearOptions = 15,
  CallOptions = 16,
  ReshapeOptions = 17,
  SkipGramOptions = 18,
  SpaceToDepthOptions = 19,
  EmbeddingLookupSparseOptions = 20,
  MulOptions = 21,
  PadOptions = 22,
  GatherOptions = 23,
  BatchToSpaceNDOptions = 24,
  SpaceToBatchNDOptions = 25,
  TransposeOptions = 26,
  ReducerOptions = 27,
  SubOptions = 28,
  DivOptions = 29,
  SqueezeOptions = 30,
  SequenceRNNOptions = 31,
  StridedSliceOptions = 32,
  ExpOptions = 33,
  TopKV2Options = 34,
  SplitOptions = 35,
  LogSoftmaxOptions = 36,
  CastOptions = 37,
  DequantizeOptions = 38,
  MaximumMinimumOptions = 39,
  ArgMaxOptions = 40,
  LessOptions = 41,
  NegOptions = 42,
  PadV2Options = 43,
  GreaterOptions = 44,
  GreaterEqualOptions = 45,
  LessEqualOptions = 46,
  SelectOptions = 47,
  SliceOptions = 48,
  TransposeConvOptions = 49,
  SparseToDenseOptions = 50,
  TileOptions = 51,
  ExpandDimsOptions = 52,
  EqualOptions = 53,
  NotEqualOptions = 54,
  ShapeOptions = 55,
  PowOptions = 56,
  ArgMinOptions = 57,
  FakeQuantOptions = 58,
  PackOptions = 59,
  LogicalOrOptions = 60,
  OneHotOptions = 61,
  LogicalAndOptions = 62,
  LogicalNotOptions = 63,
  UnpackOptions = 64,
  FloorDivOptions = 65,
  SquareOptions = 66,
  ZerosLikeOptions = 67,
  FillOptions = 68,
  BidirectionalSequenceLSTMOptions = 69,
  BidirectionalSequenceRNNOptions = 70,
  UnidirectionalSequenceLSTMOptions = 71,
  FloorModOptions = 72,
  RangeOptions = 73,
  ResizeNearestNeighborOptions = 74,
  LeakyReluOptions = 75,
  SquaredDifferenceOptions = 76,
  MirrorPadOptions = 77,
  AbsOptions = 78,
  SplitVOptions = 79,
  UniqueOptions = 80,
  ReverseV2Options = 81,
  AddNOptions = 82,
  GatherNdOptions = 83,
  CosOptions = 84,
  WhereOptions = 85,
  RankOptions = 86,
  ReverseSequenceOptions = 87,
  MatrixDiagOptions = 88,
  QuantizeOptions = 89,
  MatrixSetDiagOptions = 90,
  HardSwishOptions = 91,
  IfOptions = 92,
  WhileOptions = 93,
  DepthToSpaceOptions = 94,
  NonMaxSuppressionV4Options = 95,
  NonMaxSuppressionV5Options = 96,
  ScatterNdOptions = 97,
  SelectV2Options = 98,
  DensifyOptions = 99,
  SegmentSumOptions = 100,
  BatchMatMulOptions = 101,
  CumsumOptions = 102,
  CallOnceOptions = 103,
  BroadcastToOptions = 104,
  Rfft2dOptions = 105,
  Conv3DOptions = 106,
  HashtableOptions = 107,
  HashtableFindOptions = 108,
  HashtableImportOptions = 109,
  HashtableSizeOptions = 110,
  VarHandleOptions = 111,
  ReadVariableOptions = 112,
  AssignVariableOptions = 113,
  RandomOptions = 114,
  BucketizeOptions = 115,
  GeluOptions = 116,
  DynamicUpdateSliceOptions = 117,
  UnsortedSegmentProdOptions = 118,
  UnsortedSegmentMaxOptions = 119,
  UnsortedSegmentMinOptions = 120,
  UnsortedSegmentSumOptions = 121,
  ATan2Options = 122,
  SignOptions = 123,
  BitcastOptions = 124,
  BitwiseXorOptions = 125,
  RightShiftOptions = 126,
};

enum BuiltinOptions2 : byte
{
  NONE = 0,
  StablehloConcatenateOptions = 1,
  StablehloBroadcastInDimOptions = 2,
  StablehloSliceOptions = 3,
  StablehloConvolutionOptions = 4,
  StablehloCustomCallOptions = 5,
  StablehloReduceOptions = 6,
  StablehloScatterOptions = 7,
  StablehloCompareOptions = 8,
  StablehloDynamicSliceOptions = 9,
  StablehloPadOptions = 10,
  StablehloIotaOptions = 11,
  StablehloDotGeneralOptions = 12,
  StablehloReduceWindowOptions = 13,
  StablehloSortOptions = 14,
  StablehloWhileOptions = 15,
  StablehloGatherOptions = 16,
  StablehloTransposeOptions = 17,
  DilateOptions = 18,
  StablehloRngBitGeneratorOptions = 19,
  ReduceWindowOptions = 20,
  StableHLOCompositeOptions = 21,
  StablehloShiftLeftOptions = 22,
  StablehloCaseOptions = 23,
};

enum StablehloPrecisionConfig : uint
{
  DEFAULT = 0,
  HIGH = 1,
  HIGHEST = 2,
};

enum StablehloComparisonDirection : uint
{
  STABLEHLO_COMPARISON_DIRECTION_EQ = 0,
  STABLEHLO_COMPARISON_DIRECTION_NE = 1,
  STABLEHLO_COMPARISON_DIRECTION_GE = 2,
  STABLEHLO_COMPARISON_DIRECTION_GT = 3,
  STABLEHLO_COMPARISON_DIRECTION_LE = 4,
  STABLEHLO_COMPARISON_DIRECTION_LT = 5,
};

enum StablehloComparisonType : uint
{
  STABLEHLO_COMPARISON_TYPE_NOTYPE = 0,
  STABLEHLO_COMPARISON_TYPE_FLOAT = 1,
  STABLEHLO_COMPARISON_TYPE_FLOAT_TOTAL_ORDER = 2,
  STABLEHLO_COMPARISON_TYPE_SIGNED = 3,
  STABLEHLO_COMPARISON_TYPE_UNSIGNED = 4,
};

enum RngAlgorithm : sbyte
{
  DEFAULT = 0,
  PHILOX = 1,
  THREEFRY = 2,
};

enum Padding : sbyte
{
  SAME = 0,
  VALID = 1,
};

enum ActivationFunctionType : sbyte
{
  NONE = 0,
  RELU = 1,
  RELU_N1_TO_1 = 2,
  RELU6 = 3,
  TANH = 4,
  SIGN_BIT = 5,
};

enum LSHProjectionType : sbyte
{
  UNKNOWN = 0,
  SPARSE = 1,
  DENSE = 2,
};

enum FullyConnectedOptionsWeightsFormat : sbyte
{
  DEFAULT = 0,
  SHUFFLED4x16INT8 = 1,
};

enum LSTMKernelType : sbyte
{
  FULL = 0,
  BASIC = 1,
};

enum CombinerType : sbyte
{
  SUM = 0,
  MEAN = 1,
  SQRTN = 2,
};

enum MirrorPadMode : sbyte
{
  REFLECT = 0,
  SYMMETRIC = 1,
};

enum ReduceWindowFunction : int
{
  UNSUPPORTED = 0,
  ADD = 1,
  MUL = 2,
  MINIMUM = 3,
  MAXIMUM = 4,
  ALL = 5,
  ANY = 6,
};

enum CustomOptionsFormat : sbyte
{
  FLEXBUFFERS = 0,
};

struct CustomQuantization : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static CustomQuantization GetRootAsCustomQuantization(ByteBuffer _bb) { return GetRootAsCustomQuantization(_bb, new CustomQuantization()); }
  public static CustomQuantization GetRootAsCustomQuantization(ByteBuffer _bb, CustomQuantization obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public CustomQuantization __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public byte Custom(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int CustomLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCustomBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetCustomBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetCustomArray() { return __p.__vector_as_array<byte>(4); }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.CustomQuantization> CreateCustomQuantization(FlatBufferBuilder builder,
      VectorOffset customOffset = default(VectorOffset)) {
    builder.StartTable(1);
    CustomQuantization.AddCustom(builder, customOffset);
    return CustomQuantization.EndCustomQuantization(builder);
  }

  public static void StartCustomQuantization(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddCustom(FlatBufferBuilder builder, VectorOffset customOffset) { builder.AddOffset(0, customOffset.Value, 0); }
  public static VectorOffset CreateCustomVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateCustomVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCustomVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCustomVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCustomVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.CustomQuantization> EndCustomQuantization(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.CustomQuantization>(o);
  }
}


static class CustomQuantizationVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*Custom*/, 1 /*byte*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct BlockwiseQuantization : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static BlockwiseQuantization GetRootAsBlockwiseQuantization(ByteBuffer _bb) { return GetRootAsBlockwiseQuantization(_bb, new BlockwiseQuantization()); }
  public static BlockwiseQuantization GetRootAsBlockwiseQuantization(ByteBuffer _bb, BlockwiseQuantization obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BlockwiseQuantization __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int Scales { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int ZeroPoints { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int BlockSize { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.BlockwiseQuantization> CreateBlockwiseQuantization(FlatBufferBuilder builder,
      int scales = 0,
      int zero_points = 0,
      int block_size = 0) {
    builder.StartTable(3);
    BlockwiseQuantization.AddBlockSize(builder, block_size);
    BlockwiseQuantization.AddZeroPoints(builder, zero_points);
    BlockwiseQuantization.AddScales(builder, scales);
    return BlockwiseQuantization.EndBlockwiseQuantization(builder);
  }

  public static void StartBlockwiseQuantization(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddScales(FlatBufferBuilder builder, int scales) { builder.AddInt(0, scales, 0); }
  public static void AddZeroPoints(FlatBufferBuilder builder, int zeroPoints) { builder.AddInt(1, zeroPoints, 0); }
  public static void AddBlockSize(FlatBufferBuilder builder, int blockSize) { builder.AddInt(2, blockSize, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.BlockwiseQuantization> EndBlockwiseQuantization(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.BlockwiseQuantization>(o);
  }
}


static class BlockwiseQuantizationVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Scales*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*ZeroPoints*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*BlockSize*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct QuantizationParameters : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static QuantizationParameters GetRootAsQuantizationParameters(ByteBuffer _bb) { return GetRootAsQuantizationParameters(_bb, new QuantizationParameters()); }
  public static QuantizationParameters GetRootAsQuantizationParameters(ByteBuffer _bb, QuantizationParameters obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public QuantizationParameters __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float Min(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(__p.__vector(o) + j * 4) : (float)0; }
  public int MinLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<float> GetMinBytes() { return __p.__vector_as_span<float>(4, 4); }
#else
  public ArraySegment<byte>? GetMinBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public float[] GetMinArray() { return __p.__vector_as_array<float>(4); }
  public float Max(int j) { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(__p.__vector(o) + j * 4) : (float)0; }
  public int MaxLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<float> GetMaxBytes() { return __p.__vector_as_span<float>(6, 4); }
#else
  public ArraySegment<byte>? GetMaxBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public float[] GetMaxArray() { return __p.__vector_as_array<float>(6); }
  public float Scale(int j) { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(__p.__vector(o) + j * 4) : (float)0; }
  public int ScaleLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<float> GetScaleBytes() { return __p.__vector_as_span<float>(8, 4); }
#else
  public ArraySegment<byte>? GetScaleBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public float[] GetScaleArray() { return __p.__vector_as_array<float>(8); }
  public long ZeroPoint(int j) { int o = __p.__offset(10); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int ZeroPointLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetZeroPointBytes() { return __p.__vector_as_span<long>(10, 8); }
#else
  public ArraySegment<byte>? GetZeroPointBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public long[] GetZeroPointArray() { return __p.__vector_as_array<long>(10); }
  public Unity.InferenceEngine.Editor.LiteRT.QuantizationDetails DetailsType { get { int o = __p.__offset(12); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.QuantizationDetails)__p.bb.Get(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.QuantizationDetails.NONE; } }
  public TTable? Details<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(14); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public Unity.InferenceEngine.Editor.LiteRT.CustomQuantization DetailsAsCustomQuantization() { return Details<Unity.InferenceEngine.Editor.LiteRT.CustomQuantization>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.BlockwiseQuantization DetailsAsBlockwiseQuantization() { return Details<Unity.InferenceEngine.Editor.LiteRT.BlockwiseQuantization>().Value; }
  public int QuantizedDimension { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.QuantizationParameters> CreateQuantizationParameters(FlatBufferBuilder builder,
      VectorOffset minOffset = default(VectorOffset),
      VectorOffset maxOffset = default(VectorOffset),
      VectorOffset scaleOffset = default(VectorOffset),
      VectorOffset zero_pointOffset = default(VectorOffset),
      Unity.InferenceEngine.Editor.LiteRT.QuantizationDetails details_type = Unity.InferenceEngine.Editor.LiteRT.QuantizationDetails.NONE,
      int detailsOffset = 0,
      int quantized_dimension = 0) {
    builder.StartTable(7);
    QuantizationParameters.AddQuantizedDimension(builder, quantized_dimension);
    QuantizationParameters.AddDetails(builder, detailsOffset);
    QuantizationParameters.AddZeroPoint(builder, zero_pointOffset);
    QuantizationParameters.AddScale(builder, scaleOffset);
    QuantizationParameters.AddMax(builder, maxOffset);
    QuantizationParameters.AddMin(builder, minOffset);
    QuantizationParameters.AddDetailsType(builder, details_type);
    return QuantizationParameters.EndQuantizationParameters(builder);
  }

  public static void StartQuantizationParameters(FlatBufferBuilder builder) { builder.StartTable(7); }
  public static void AddMin(FlatBufferBuilder builder, VectorOffset minOffset) { builder.AddOffset(0, minOffset.Value, 0); }
  public static VectorOffset CreateMinVector(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddFloat(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateMinVectorBlock(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMinVectorBlock(FlatBufferBuilder builder, ArraySegment<float> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMinVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<float>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartMinVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddMax(FlatBufferBuilder builder, VectorOffset maxOffset) { builder.AddOffset(1, maxOffset.Value, 0); }
  public static VectorOffset CreateMaxVector(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddFloat(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateMaxVectorBlock(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMaxVectorBlock(FlatBufferBuilder builder, ArraySegment<float> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMaxVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<float>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartMaxVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddScale(FlatBufferBuilder builder, VectorOffset scaleOffset) { builder.AddOffset(2, scaleOffset.Value, 0); }
  public static VectorOffset CreateScaleVector(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddFloat(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateScaleVectorBlock(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateScaleVectorBlock(FlatBufferBuilder builder, ArraySegment<float> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateScaleVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<float>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartScaleVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddZeroPoint(FlatBufferBuilder builder, VectorOffset zeroPointOffset) { builder.AddOffset(3, zeroPointOffset.Value, 0); }
  public static VectorOffset CreateZeroPointVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateZeroPointVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateZeroPointVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateZeroPointVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartZeroPointVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddDetailsType(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.QuantizationDetails detailsType) { builder.AddByte(4, (byte)detailsType, 0); }
  public static void AddDetails(FlatBufferBuilder builder, int detailsOffset) { builder.AddOffset(5, detailsOffset, 0); }
  public static void AddQuantizedDimension(FlatBufferBuilder builder, int quantizedDimension) { builder.AddInt(6, quantizedDimension, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.QuantizationParameters> EndQuantizationParameters(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.QuantizationParameters>(o);
  }
}


static class QuantizationParametersVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*Min*/, 4 /*float*/, false)
      && verifier.VerifyVectorOfData(tablePos, 6 /*Max*/, 4 /*float*/, false)
      && verifier.VerifyVectorOfData(tablePos, 8 /*Scale*/, 4 /*float*/, false)
      && verifier.VerifyVectorOfData(tablePos, 10 /*ZeroPoint*/, 8 /*long*/, false)
      && verifier.VerifyField(tablePos, 12 /*DetailsType*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.QuantizationDetails*/, 1, false)
      // && verifier.VerifyUnion(tablePos, 12, 14 /*Details*/, Unity.InferenceEngine.Editor.LiteRT.QuantizationDetailsVerify.Verify, false)
      && verifier.VerifyField(tablePos, 16 /*QuantizedDimension*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct Int32Vector : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static Int32Vector GetRootAsInt32Vector(ByteBuffer _bb) { return GetRootAsInt32Vector(_bb, new Int32Vector()); }
  public static Int32Vector GetRootAsInt32Vector(ByteBuffer _bb, Int32Vector obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Int32Vector __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int Values(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int ValuesLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetValuesBytes() { return __p.__vector_as_span<int>(4, 4); }
#else
  public ArraySegment<byte>? GetValuesBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public int[] GetValuesArray() { return __p.__vector_as_array<int>(4); }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Int32Vector> CreateInt32Vector(FlatBufferBuilder builder,
      VectorOffset valuesOffset = default(VectorOffset)) {
    builder.StartTable(1);
    Int32Vector.AddValues(builder, valuesOffset);
    return Int32Vector.EndInt32Vector(builder);
  }

  public static void StartInt32Vector(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddValues(FlatBufferBuilder builder, VectorOffset valuesOffset) { builder.AddOffset(0, valuesOffset.Value, 0); }
  public static VectorOffset CreateValuesVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateValuesVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateValuesVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateValuesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartValuesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Int32Vector> EndInt32Vector(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.Int32Vector>(o);
  }
}


static class Int32VectorVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*Values*/, 4 /*int*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct Uint16Vector : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static Uint16Vector GetRootAsUint16Vector(ByteBuffer _bb) { return GetRootAsUint16Vector(_bb, new Uint16Vector()); }
  public static Uint16Vector GetRootAsUint16Vector(ByteBuffer _bb, Uint16Vector obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Uint16Vector __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public ushort Values(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUshort(__p.__vector(o) + j * 2) : (ushort)0; }
  public int ValuesLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<ushort> GetValuesBytes() { return __p.__vector_as_span<ushort>(4, 2); }
#else
  public ArraySegment<byte>? GetValuesBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public ushort[] GetValuesArray() { return __p.__vector_as_array<ushort>(4); }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Uint16Vector> CreateUint16Vector(FlatBufferBuilder builder,
      VectorOffset valuesOffset = default(VectorOffset)) {
    builder.StartTable(1);
    Uint16Vector.AddValues(builder, valuesOffset);
    return Uint16Vector.EndUint16Vector(builder);
  }

  public static void StartUint16Vector(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddValues(FlatBufferBuilder builder, VectorOffset valuesOffset) { builder.AddOffset(0, valuesOffset.Value, 0); }
  public static VectorOffset CreateValuesVector(FlatBufferBuilder builder, ushort[] data) { builder.StartVector(2, data.Length, 2); for (int i = data.Length - 1; i >= 0; i--) builder.AddUshort(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateValuesVectorBlock(FlatBufferBuilder builder, ushort[] data) { builder.StartVector(2, data.Length, 2); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateValuesVectorBlock(FlatBufferBuilder builder, ArraySegment<ushort> data) { builder.StartVector(2, data.Count, 2); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateValuesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<ushort>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartValuesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(2, numElems, 2); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Uint16Vector> EndUint16Vector(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.Uint16Vector>(o);
  }
}


static class Uint16VectorVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*Values*/, 2 /*ushort*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct Uint8Vector : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static Uint8Vector GetRootAsUint8Vector(ByteBuffer _bb) { return GetRootAsUint8Vector(_bb, new Uint8Vector()); }
  public static Uint8Vector GetRootAsUint8Vector(ByteBuffer _bb, Uint8Vector obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Uint8Vector __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public byte Values(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int ValuesLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetValuesBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetValuesBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetValuesArray() { return __p.__vector_as_array<byte>(4); }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Uint8Vector> CreateUint8Vector(FlatBufferBuilder builder,
      VectorOffset valuesOffset = default(VectorOffset)) {
    builder.StartTable(1);
    Uint8Vector.AddValues(builder, valuesOffset);
    return Uint8Vector.EndUint8Vector(builder);
  }

  public static void StartUint8Vector(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddValues(FlatBufferBuilder builder, VectorOffset valuesOffset) { builder.AddOffset(0, valuesOffset.Value, 0); }
  public static VectorOffset CreateValuesVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateValuesVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateValuesVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateValuesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartValuesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Uint8Vector> EndUint8Vector(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.Uint8Vector>(o);
  }
}


static class Uint8VectorVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*Values*/, 1 /*byte*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct DimensionMetadata : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static DimensionMetadata GetRootAsDimensionMetadata(ByteBuffer _bb) { return GetRootAsDimensionMetadata(_bb, new DimensionMetadata()); }
  public static DimensionMetadata GetRootAsDimensionMetadata(ByteBuffer _bb, DimensionMetadata obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DimensionMetadata __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.DimensionType Format { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.DimensionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.DimensionType.DENSE; } }
  public int DenseSize { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public Unity.InferenceEngine.Editor.LiteRT.SparseIndexVector ArraySegmentsType { get { int o = __p.__offset(8); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.SparseIndexVector)__p.bb.Get(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.SparseIndexVector.NONE; } }
  public TTable? ArraySegments<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(10); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public Unity.InferenceEngine.Editor.LiteRT.Int32Vector ArraySegmentsAsInt32Vector() { return ArraySegments<Unity.InferenceEngine.Editor.LiteRT.Int32Vector>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.Uint16Vector ArraySegmentsAsUint16Vector() { return ArraySegments<Unity.InferenceEngine.Editor.LiteRT.Uint16Vector>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.Uint8Vector ArraySegmentsAsUint8Vector() { return ArraySegments<Unity.InferenceEngine.Editor.LiteRT.Uint8Vector>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.SparseIndexVector ArrayIndicesType { get { int o = __p.__offset(12); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.SparseIndexVector)__p.bb.Get(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.SparseIndexVector.NONE; } }
  public TTable? ArrayIndices<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(14); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public Unity.InferenceEngine.Editor.LiteRT.Int32Vector ArrayIndicesAsInt32Vector() { return ArrayIndices<Unity.InferenceEngine.Editor.LiteRT.Int32Vector>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.Uint16Vector ArrayIndicesAsUint16Vector() { return ArrayIndices<Unity.InferenceEngine.Editor.LiteRT.Uint16Vector>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.Uint8Vector ArrayIndicesAsUint8Vector() { return ArrayIndices<Unity.InferenceEngine.Editor.LiteRT.Uint8Vector>().Value; }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.DimensionMetadata> CreateDimensionMetadata(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.DimensionType format = Unity.InferenceEngine.Editor.LiteRT.DimensionType.DENSE,
      int dense_size = 0,
      Unity.InferenceEngine.Editor.LiteRT.SparseIndexVector array_segments_type = Unity.InferenceEngine.Editor.LiteRT.SparseIndexVector.NONE,
      int array_segmentsOffset = 0,
      Unity.InferenceEngine.Editor.LiteRT.SparseIndexVector array_indices_type = Unity.InferenceEngine.Editor.LiteRT.SparseIndexVector.NONE,
      int array_indicesOffset = 0) {
    builder.StartTable(6);
    DimensionMetadata.AddArrayIndices(builder, array_indicesOffset);
    DimensionMetadata.AddArraySegments(builder, array_segmentsOffset);
    DimensionMetadata.AddDenseSize(builder, dense_size);
    DimensionMetadata.AddArrayIndicesType(builder, array_indices_type);
    DimensionMetadata.AddArraySegmentsType(builder, array_segments_type);
    DimensionMetadata.AddFormat(builder, format);
    return DimensionMetadata.EndDimensionMetadata(builder);
  }

  public static void StartDimensionMetadata(FlatBufferBuilder builder) { builder.StartTable(6); }
  public static void AddFormat(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.DimensionType format) { builder.AddSbyte(0, (sbyte)format, 0); }
  public static void AddDenseSize(FlatBufferBuilder builder, int denseSize) { builder.AddInt(1, denseSize, 0); }
  public static void AddArraySegmentsType(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.SparseIndexVector arraySegmentsType) { builder.AddByte(2, (byte)arraySegmentsType, 0); }
  public static void AddArraySegments(FlatBufferBuilder builder, int arraySegmentsOffset) { builder.AddOffset(3, arraySegmentsOffset, 0); }
  public static void AddArrayIndicesType(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.SparseIndexVector arrayIndicesType) { builder.AddByte(4, (byte)arrayIndicesType, 0); }
  public static void AddArrayIndices(FlatBufferBuilder builder, int arrayIndicesOffset) { builder.AddOffset(5, arrayIndicesOffset, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.DimensionMetadata> EndDimensionMetadata(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.DimensionMetadata>(o);
  }
}


static class DimensionMetadataVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Format*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.DimensionType*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*DenseSize*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*ArraySegmentsType*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.SparseIndexVector*/, 1, false)
      // && verifier.VerifyUnion(tablePos, 8, 10 /*ArraySegments*/, Unity.InferenceEngine.Editor.LiteRT.SparseIndexVectorVerify.Verify, false)
      && verifier.VerifyField(tablePos, 12 /*ArrayIndicesType*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.SparseIndexVector*/, 1, false)
      // && verifier.VerifyUnion(tablePos, 12, 14 /*ArrayIndices*/, Unity.InferenceEngine.Editor.LiteRT.SparseIndexVectorVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SparsityParameters : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SparsityParameters GetRootAsSparsityParameters(ByteBuffer _bb) { return GetRootAsSparsityParameters(_bb, new SparsityParameters()); }
  public static SparsityParameters GetRootAsSparsityParameters(ByteBuffer _bb, SparsityParameters obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SparsityParameters __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int TraversalOrder(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int TraversalOrderLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetTraversalOrderBytes() { return __p.__vector_as_span<int>(4, 4); }
#else
  public ArraySegment<byte>? GetTraversalOrderBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public int[] GetTraversalOrderArray() { return __p.__vector_as_array<int>(4); }
  public int BlockMap(int j) { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int BlockMapLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetBlockMapBytes() { return __p.__vector_as_span<int>(6, 4); }
#else
  public ArraySegment<byte>? GetBlockMapBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public int[] GetBlockMapArray() { return __p.__vector_as_array<int>(6); }
  public Unity.InferenceEngine.Editor.LiteRT.DimensionMetadata? DimMetadata(int j) { int o = __p.__offset(8); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.DimensionMetadata?)(new Unity.InferenceEngine.Editor.LiteRT.DimensionMetadata()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int DimMetadataLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SparsityParameters> CreateSparsityParameters(FlatBufferBuilder builder,
      VectorOffset traversal_orderOffset = default(VectorOffset),
      VectorOffset block_mapOffset = default(VectorOffset),
      VectorOffset dim_metadataOffset = default(VectorOffset)) {
    builder.StartTable(3);
    SparsityParameters.AddDimMetadata(builder, dim_metadataOffset);
    SparsityParameters.AddBlockMap(builder, block_mapOffset);
    SparsityParameters.AddTraversalOrder(builder, traversal_orderOffset);
    return SparsityParameters.EndSparsityParameters(builder);
  }

  public static void StartSparsityParameters(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddTraversalOrder(FlatBufferBuilder builder, VectorOffset traversalOrderOffset) { builder.AddOffset(0, traversalOrderOffset.Value, 0); }
  public static VectorOffset CreateTraversalOrderVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateTraversalOrderVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTraversalOrderVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTraversalOrderVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartTraversalOrderVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddBlockMap(FlatBufferBuilder builder, VectorOffset blockMapOffset) { builder.AddOffset(1, blockMapOffset.Value, 0); }
  public static VectorOffset CreateBlockMapVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateBlockMapVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBlockMapVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBlockMapVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartBlockMapVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddDimMetadata(FlatBufferBuilder builder, VectorOffset dimMetadataOffset) { builder.AddOffset(2, dimMetadataOffset.Value, 0); }
  public static VectorOffset CreateDimMetadataVector(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.DimensionMetadata>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateDimMetadataVectorBlock(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.DimensionMetadata>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateDimMetadataVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Unity.InferenceEngine.Editor.LiteRT.DimensionMetadata>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateDimMetadataVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Unity.InferenceEngine.Editor.LiteRT.DimensionMetadata>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartDimMetadataVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SparsityParameters> EndSparsityParameters(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SparsityParameters>(o);
  }
}


static class SparsityParametersVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*TraversalOrder*/, 4 /*int*/, false)
      && verifier.VerifyVectorOfData(tablePos, 6 /*BlockMap*/, 4 /*int*/, false)
      && verifier.VerifyVectorOfTables(tablePos, 8 /*DimMetadata*/, Unity.InferenceEngine.Editor.LiteRT.DimensionMetadataVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct VariantSubType : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static VariantSubType GetRootAsVariantSubType(ByteBuffer _bb) { return GetRootAsVariantSubType(_bb, new VariantSubType()); }
  public static VariantSubType GetRootAsVariantSubType(ByteBuffer _bb, VariantSubType obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public VariantSubType __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int Shape(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int ShapeLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetShapeBytes() { return __p.__vector_as_span<int>(4, 4); }
#else
  public ArraySegment<byte>? GetShapeBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public int[] GetShapeArray() { return __p.__vector_as_array<int>(4); }
  public Unity.InferenceEngine.Editor.LiteRT.TensorType Type { get { int o = __p.__offset(6); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.TensorType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32; } }
  public bool HasRank { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.VariantSubType> CreateVariantSubType(FlatBufferBuilder builder,
      VectorOffset shapeOffset = default(VectorOffset),
      Unity.InferenceEngine.Editor.LiteRT.TensorType type = Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32,
      bool has_rank = false) {
    builder.StartTable(3);
    VariantSubType.AddShape(builder, shapeOffset);
    VariantSubType.AddHasRank(builder, has_rank);
    VariantSubType.AddType(builder, type);
    return VariantSubType.EndVariantSubType(builder);
  }

  public static void StartVariantSubType(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddShape(FlatBufferBuilder builder, VectorOffset shapeOffset) { builder.AddOffset(0, shapeOffset.Value, 0); }
  public static VectorOffset CreateShapeVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateShapeVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateShapeVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateShapeVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartShapeVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddType(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.TensorType type) { builder.AddSbyte(1, (sbyte)type, 0); }
  public static void AddHasRank(FlatBufferBuilder builder, bool hasRank) { builder.AddBool(2, hasRank, false); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.VariantSubType> EndVariantSubType(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.VariantSubType>(o);
  }
}


static class VariantSubTypeVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*Shape*/, 4 /*int*/, false)
      && verifier.VerifyField(tablePos, 6 /*Type*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.TensorType*/, 1, false)
      && verifier.VerifyField(tablePos, 8 /*HasRank*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct Tensor : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static Tensor GetRootAsTensor(ByteBuffer _bb) { return GetRootAsTensor(_bb, new Tensor()); }
  public static Tensor GetRootAsTensor(ByteBuffer _bb, Tensor obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Tensor __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int Shape(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int ShapeLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetShapeBytes() { return __p.__vector_as_span<int>(4, 4); }
#else
  public ArraySegment<byte>? GetShapeBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public int[] GetShapeArray() { return __p.__vector_as_array<int>(4); }
  public Unity.InferenceEngine.Editor.LiteRT.TensorType Type { get { int o = __p.__offset(6); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.TensorType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32; } }
  public uint Buffer { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public string Name { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(10); }
  public Unity.InferenceEngine.Editor.LiteRT.QuantizationParameters? Quantization { get { int o = __p.__offset(12); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.QuantizationParameters?)(new Unity.InferenceEngine.Editor.LiteRT.QuantizationParameters()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public bool IsVariable { get { int o = __p.__offset(14); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public Unity.InferenceEngine.Editor.LiteRT.SparsityParameters? Sparsity { get { int o = __p.__offset(16); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.SparsityParameters?)(new Unity.InferenceEngine.Editor.LiteRT.SparsityParameters()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public int ShapeSignature(int j) { int o = __p.__offset(18); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int ShapeSignatureLength { get { int o = __p.__offset(18); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetShapeSignatureBytes() { return __p.__vector_as_span<int>(18, 4); }
#else
  public ArraySegment<byte>? GetShapeSignatureBytes() { return __p.__vector_as_arraysegment(18); }
#endif
  public int[] GetShapeSignatureArray() { return __p.__vector_as_array<int>(18); }
  public bool HasRank { get { int o = __p.__offset(20); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public Unity.InferenceEngine.Editor.LiteRT.VariantSubType? VariantTensors(int j) { int o = __p.__offset(22); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.VariantSubType?)(new Unity.InferenceEngine.Editor.LiteRT.VariantSubType()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int VariantTensorsLength { get { int o = __p.__offset(22); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Tensor> CreateTensor(FlatBufferBuilder builder,
      VectorOffset shapeOffset = default(VectorOffset),
      Unity.InferenceEngine.Editor.LiteRT.TensorType type = Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32,
      uint buffer = 0,
      StringOffset nameOffset = default(StringOffset),
      Offset<Unity.InferenceEngine.Editor.LiteRT.QuantizationParameters> quantizationOffset = default(Offset<Unity.InferenceEngine.Editor.LiteRT.QuantizationParameters>),
      bool is_variable = false,
      Offset<Unity.InferenceEngine.Editor.LiteRT.SparsityParameters> sparsityOffset = default(Offset<Unity.InferenceEngine.Editor.LiteRT.SparsityParameters>),
      VectorOffset shape_signatureOffset = default(VectorOffset),
      bool has_rank = false,
      VectorOffset variant_tensorsOffset = default(VectorOffset)) {
    builder.StartTable(10);
    Tensor.AddVariantTensors(builder, variant_tensorsOffset);
    Tensor.AddShapeSignature(builder, shape_signatureOffset);
    Tensor.AddSparsity(builder, sparsityOffset);
    Tensor.AddQuantization(builder, quantizationOffset);
    Tensor.AddName(builder, nameOffset);
    Tensor.AddBuffer(builder, buffer);
    Tensor.AddShape(builder, shapeOffset);
    Tensor.AddHasRank(builder, has_rank);
    Tensor.AddIsVariable(builder, is_variable);
    Tensor.AddType(builder, type);
    return Tensor.EndTensor(builder);
  }

  public static void StartTensor(FlatBufferBuilder builder) { builder.StartTable(10); }
  public static void AddShape(FlatBufferBuilder builder, VectorOffset shapeOffset) { builder.AddOffset(0, shapeOffset.Value, 0); }
  public static VectorOffset CreateShapeVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateShapeVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateShapeVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateShapeVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartShapeVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddType(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.TensorType type) { builder.AddSbyte(1, (sbyte)type, 0); }
  public static void AddBuffer(FlatBufferBuilder builder, uint buffer) { builder.AddUint(2, buffer, 0); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(3, nameOffset.Value, 0); }
  public static void AddQuantization(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.QuantizationParameters> quantizationOffset) { builder.AddOffset(4, quantizationOffset.Value, 0); }
  public static void AddIsVariable(FlatBufferBuilder builder, bool isVariable) { builder.AddBool(5, isVariable, false); }
  public static void AddSparsity(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.SparsityParameters> sparsityOffset) { builder.AddOffset(6, sparsityOffset.Value, 0); }
  public static void AddShapeSignature(FlatBufferBuilder builder, VectorOffset shapeSignatureOffset) { builder.AddOffset(7, shapeSignatureOffset.Value, 0); }
  public static VectorOffset CreateShapeSignatureVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateShapeSignatureVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateShapeSignatureVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateShapeSignatureVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartShapeSignatureVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddHasRank(FlatBufferBuilder builder, bool hasRank) { builder.AddBool(8, hasRank, false); }
  public static void AddVariantTensors(FlatBufferBuilder builder, VectorOffset variantTensorsOffset) { builder.AddOffset(9, variantTensorsOffset.Value, 0); }
  public static VectorOffset CreateVariantTensorsVector(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.VariantSubType>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateVariantTensorsVectorBlock(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.VariantSubType>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateVariantTensorsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Unity.InferenceEngine.Editor.LiteRT.VariantSubType>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateVariantTensorsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Unity.InferenceEngine.Editor.LiteRT.VariantSubType>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartVariantTensorsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Tensor> EndTensor(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.Tensor>(o);
  }
}


static class TensorVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*Shape*/, 4 /*int*/, false)
      && verifier.VerifyField(tablePos, 6 /*Type*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.TensorType*/, 1, false)
      && verifier.VerifyField(tablePos, 8 /*Buffer*/, 4 /*uint*/, 4, false)
      && verifier.VerifyString(tablePos, 10 /*Name*/, false)
      && verifier.VerifyTable(tablePos, 12 /*Quantization*/, Unity.InferenceEngine.Editor.LiteRT.QuantizationParametersVerify.Verify, false)
      && verifier.VerifyField(tablePos, 14 /*IsVariable*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTable(tablePos, 16 /*Sparsity*/, Unity.InferenceEngine.Editor.LiteRT.SparsityParametersVerify.Verify, false)
      && verifier.VerifyVectorOfData(tablePos, 18 /*ShapeSignature*/, 4 /*int*/, false)
      && verifier.VerifyField(tablePos, 20 /*HasRank*/, 1 /*bool*/, 1, false)
      && verifier.VerifyVectorOfTables(tablePos, 22 /*VariantTensors*/, Unity.InferenceEngine.Editor.LiteRT.VariantSubTypeVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloGatherOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloGatherOptions GetRootAsStablehloGatherOptions(ByteBuffer _bb) { return GetRootAsStablehloGatherOptions(_bb, new StablehloGatherOptions()); }
  public static StablehloGatherOptions GetRootAsStablehloGatherOptions(ByteBuffer _bb, StablehloGatherOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloGatherOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public long OffsetDims(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int OffsetDimsLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetOffsetDimsBytes() { return __p.__vector_as_span<long>(4, 8); }
#else
  public ArraySegment<byte>? GetOffsetDimsBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public long[] GetOffsetDimsArray() { return __p.__vector_as_array<long>(4); }
  public long CollapsedSliceDims(int j) { int o = __p.__offset(6); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int CollapsedSliceDimsLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetCollapsedSliceDimsBytes() { return __p.__vector_as_span<long>(6, 8); }
#else
  public ArraySegment<byte>? GetCollapsedSliceDimsBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public long[] GetCollapsedSliceDimsArray() { return __p.__vector_as_array<long>(6); }
  public long StartIndexMap(int j) { int o = __p.__offset(8); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int StartIndexMapLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetStartIndexMapBytes() { return __p.__vector_as_span<long>(8, 8); }
#else
  public ArraySegment<byte>? GetStartIndexMapBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public long[] GetStartIndexMapArray() { return __p.__vector_as_array<long>(8); }
  public long IndexVectorDim { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public long SliceSizes(int j) { int o = __p.__offset(12); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int SliceSizesLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetSliceSizesBytes() { return __p.__vector_as_span<long>(12, 8); }
#else
  public ArraySegment<byte>? GetSliceSizesBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public long[] GetSliceSizesArray() { return __p.__vector_as_array<long>(12); }
  public bool IndicesAreSorted { get { int o = __p.__offset(14); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloGatherOptions> CreateStablehloGatherOptions(FlatBufferBuilder builder,
      VectorOffset offset_dimsOffset = default(VectorOffset),
      VectorOffset collapsed_slice_dimsOffset = default(VectorOffset),
      VectorOffset start_index_mapOffset = default(VectorOffset),
      long index_vector_dim = 0,
      VectorOffset slice_sizesOffset = default(VectorOffset),
      bool indices_are_sorted = false) {
    builder.StartTable(6);
    StablehloGatherOptions.AddIndexVectorDim(builder, index_vector_dim);
    StablehloGatherOptions.AddSliceSizes(builder, slice_sizesOffset);
    StablehloGatherOptions.AddStartIndexMap(builder, start_index_mapOffset);
    StablehloGatherOptions.AddCollapsedSliceDims(builder, collapsed_slice_dimsOffset);
    StablehloGatherOptions.AddOffsetDims(builder, offset_dimsOffset);
    StablehloGatherOptions.AddIndicesAreSorted(builder, indices_are_sorted);
    return StablehloGatherOptions.EndStablehloGatherOptions(builder);
  }

  public static void StartStablehloGatherOptions(FlatBufferBuilder builder) { builder.StartTable(6); }
  public static void AddOffsetDims(FlatBufferBuilder builder, VectorOffset offsetDimsOffset) { builder.AddOffset(0, offsetDimsOffset.Value, 0); }
  public static VectorOffset CreateOffsetDimsVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateOffsetDimsVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateOffsetDimsVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateOffsetDimsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartOffsetDimsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddCollapsedSliceDims(FlatBufferBuilder builder, VectorOffset collapsedSliceDimsOffset) { builder.AddOffset(1, collapsedSliceDimsOffset.Value, 0); }
  public static VectorOffset CreateCollapsedSliceDimsVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateCollapsedSliceDimsVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCollapsedSliceDimsVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCollapsedSliceDimsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCollapsedSliceDimsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddStartIndexMap(FlatBufferBuilder builder, VectorOffset startIndexMapOffset) { builder.AddOffset(2, startIndexMapOffset.Value, 0); }
  public static VectorOffset CreateStartIndexMapVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateStartIndexMapVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateStartIndexMapVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateStartIndexMapVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartStartIndexMapVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddIndexVectorDim(FlatBufferBuilder builder, long indexVectorDim) { builder.AddLong(3, indexVectorDim, 0); }
  public static void AddSliceSizes(FlatBufferBuilder builder, VectorOffset sliceSizesOffset) { builder.AddOffset(4, sliceSizesOffset.Value, 0); }
  public static VectorOffset CreateSliceSizesVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateSliceSizesVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSliceSizesVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSliceSizesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSliceSizesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddIndicesAreSorted(FlatBufferBuilder builder, bool indicesAreSorted) { builder.AddBool(5, indicesAreSorted, false); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloGatherOptions> EndStablehloGatherOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloGatherOptions>(o);
  }
}


static class StablehloGatherOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*OffsetDims*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 6 /*CollapsedSliceDims*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 8 /*StartIndexMap*/, 8 /*long*/, false)
      && verifier.VerifyField(tablePos, 10 /*IndexVectorDim*/, 8 /*long*/, 8, false)
      && verifier.VerifyVectorOfData(tablePos, 12 /*SliceSizes*/, 8 /*long*/, false)
      && verifier.VerifyField(tablePos, 14 /*IndicesAreSorted*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloTransposeOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloTransposeOptions GetRootAsStablehloTransposeOptions(ByteBuffer _bb) { return GetRootAsStablehloTransposeOptions(_bb, new StablehloTransposeOptions()); }
  public static StablehloTransposeOptions GetRootAsStablehloTransposeOptions(ByteBuffer _bb, StablehloTransposeOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloTransposeOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public long Permutation(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int PermutationLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetPermutationBytes() { return __p.__vector_as_span<long>(4, 8); }
#else
  public ArraySegment<byte>? GetPermutationBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public long[] GetPermutationArray() { return __p.__vector_as_array<long>(4); }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloTransposeOptions> CreateStablehloTransposeOptions(FlatBufferBuilder builder,
      VectorOffset permutationOffset = default(VectorOffset)) {
    builder.StartTable(1);
    StablehloTransposeOptions.AddPermutation(builder, permutationOffset);
    return StablehloTransposeOptions.EndStablehloTransposeOptions(builder);
  }

  public static void StartStablehloTransposeOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddPermutation(FlatBufferBuilder builder, VectorOffset permutationOffset) { builder.AddOffset(0, permutationOffset.Value, 0); }
  public static VectorOffset CreatePermutationVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreatePermutationVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePermutationVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePermutationVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPermutationVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloTransposeOptions> EndStablehloTransposeOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloTransposeOptions>(o);
  }
}


static class StablehloTransposeOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*Permutation*/, 8 /*long*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloDotGeneralOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloDotGeneralOptions GetRootAsStablehloDotGeneralOptions(ByteBuffer _bb) { return GetRootAsStablehloDotGeneralOptions(_bb, new StablehloDotGeneralOptions()); }
  public static StablehloDotGeneralOptions GetRootAsStablehloDotGeneralOptions(ByteBuffer _bb, StablehloDotGeneralOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloDotGeneralOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public long LhsBatchingDimensions(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int LhsBatchingDimensionsLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetLhsBatchingDimensionsBytes() { return __p.__vector_as_span<long>(4, 8); }
#else
  public ArraySegment<byte>? GetLhsBatchingDimensionsBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public long[] GetLhsBatchingDimensionsArray() { return __p.__vector_as_array<long>(4); }
  public long RhsBatchingDimensions(int j) { int o = __p.__offset(6); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int RhsBatchingDimensionsLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetRhsBatchingDimensionsBytes() { return __p.__vector_as_span<long>(6, 8); }
#else
  public ArraySegment<byte>? GetRhsBatchingDimensionsBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public long[] GetRhsBatchingDimensionsArray() { return __p.__vector_as_array<long>(6); }
  public long LhsContractingDimensions(int j) { int o = __p.__offset(8); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int LhsContractingDimensionsLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetLhsContractingDimensionsBytes() { return __p.__vector_as_span<long>(8, 8); }
#else
  public ArraySegment<byte>? GetLhsContractingDimensionsBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public long[] GetLhsContractingDimensionsArray() { return __p.__vector_as_array<long>(8); }
  public long RhsContractingDimensions(int j) { int o = __p.__offset(10); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int RhsContractingDimensionsLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetRhsContractingDimensionsBytes() { return __p.__vector_as_span<long>(10, 8); }
#else
  public ArraySegment<byte>? GetRhsContractingDimensionsBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public long[] GetRhsContractingDimensionsArray() { return __p.__vector_as_array<long>(10); }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig PrecisionConfig(int j) { int o = __p.__offset(12); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig)__p.bb.GetUint(__p.__vector(o) + j * 4) : (Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig)0; }
  public int PrecisionConfigLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig> GetPrecisionConfigBytes() { return __p.__vector_as_span<Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig>(12, 4); }
#else
  public ArraySegment<byte>? GetPrecisionConfigBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig[] GetPrecisionConfigArray() { int o = __p.__offset(12); if (o == 0) return null; int p = __p.__vector(o); int l = __p.__vector_len(o); Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig[] a = new Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig[l]; for (int i = 0; i < l; i++) { a[i] = (Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig)__p.bb.GetUint(p + i * 4); } return a; }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloDotGeneralOptions> CreateStablehloDotGeneralOptions(FlatBufferBuilder builder,
      VectorOffset lhs_batching_dimensionsOffset = default(VectorOffset),
      VectorOffset rhs_batching_dimensionsOffset = default(VectorOffset),
      VectorOffset lhs_contracting_dimensionsOffset = default(VectorOffset),
      VectorOffset rhs_contracting_dimensionsOffset = default(VectorOffset),
      VectorOffset precision_configOffset = default(VectorOffset)) {
    builder.StartTable(5);
    StablehloDotGeneralOptions.AddPrecisionConfig(builder, precision_configOffset);
    StablehloDotGeneralOptions.AddRhsContractingDimensions(builder, rhs_contracting_dimensionsOffset);
    StablehloDotGeneralOptions.AddLhsContractingDimensions(builder, lhs_contracting_dimensionsOffset);
    StablehloDotGeneralOptions.AddRhsBatchingDimensions(builder, rhs_batching_dimensionsOffset);
    StablehloDotGeneralOptions.AddLhsBatchingDimensions(builder, lhs_batching_dimensionsOffset);
    return StablehloDotGeneralOptions.EndStablehloDotGeneralOptions(builder);
  }

  public static void StartStablehloDotGeneralOptions(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddLhsBatchingDimensions(FlatBufferBuilder builder, VectorOffset lhsBatchingDimensionsOffset) { builder.AddOffset(0, lhsBatchingDimensionsOffset.Value, 0); }
  public static VectorOffset CreateLhsBatchingDimensionsVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateLhsBatchingDimensionsVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLhsBatchingDimensionsVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLhsBatchingDimensionsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartLhsBatchingDimensionsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddRhsBatchingDimensions(FlatBufferBuilder builder, VectorOffset rhsBatchingDimensionsOffset) { builder.AddOffset(1, rhsBatchingDimensionsOffset.Value, 0); }
  public static VectorOffset CreateRhsBatchingDimensionsVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateRhsBatchingDimensionsVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRhsBatchingDimensionsVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRhsBatchingDimensionsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartRhsBatchingDimensionsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddLhsContractingDimensions(FlatBufferBuilder builder, VectorOffset lhsContractingDimensionsOffset) { builder.AddOffset(2, lhsContractingDimensionsOffset.Value, 0); }
  public static VectorOffset CreateLhsContractingDimensionsVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateLhsContractingDimensionsVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLhsContractingDimensionsVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLhsContractingDimensionsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartLhsContractingDimensionsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddRhsContractingDimensions(FlatBufferBuilder builder, VectorOffset rhsContractingDimensionsOffset) { builder.AddOffset(3, rhsContractingDimensionsOffset.Value, 0); }
  public static VectorOffset CreateRhsContractingDimensionsVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateRhsContractingDimensionsVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRhsContractingDimensionsVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRhsContractingDimensionsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartRhsContractingDimensionsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddPrecisionConfig(FlatBufferBuilder builder, VectorOffset precisionConfigOffset) { builder.AddOffset(4, precisionConfigOffset.Value, 0); }
  public static VectorOffset CreatePrecisionConfigVector(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddUint((uint)data[i]); return builder.EndVector(); }
  public static VectorOffset CreatePrecisionConfigVectorBlock(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePrecisionConfigVectorBlock(FlatBufferBuilder builder, ArraySegment<Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePrecisionConfigVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPrecisionConfigVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloDotGeneralOptions> EndStablehloDotGeneralOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloDotGeneralOptions>(o);
  }
}


static class StablehloDotGeneralOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*LhsBatchingDimensions*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 6 /*RhsBatchingDimensions*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 8 /*LhsContractingDimensions*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 10 /*RhsContractingDimensions*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 12 /*PrecisionConfig*/, 4 /*Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloReduceWindowOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloReduceWindowOptions GetRootAsStablehloReduceWindowOptions(ByteBuffer _bb) { return GetRootAsStablehloReduceWindowOptions(_bb, new StablehloReduceWindowOptions()); }
  public static StablehloReduceWindowOptions GetRootAsStablehloReduceWindowOptions(ByteBuffer _bb, StablehloReduceWindowOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloReduceWindowOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public long WindowDimensions(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int WindowDimensionsLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetWindowDimensionsBytes() { return __p.__vector_as_span<long>(4, 8); }
#else
  public ArraySegment<byte>? GetWindowDimensionsBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public long[] GetWindowDimensionsArray() { return __p.__vector_as_array<long>(4); }
  public long WindowStrides(int j) { int o = __p.__offset(6); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int WindowStridesLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetWindowStridesBytes() { return __p.__vector_as_span<long>(6, 8); }
#else
  public ArraySegment<byte>? GetWindowStridesBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public long[] GetWindowStridesArray() { return __p.__vector_as_array<long>(6); }
  public long BaseDilations(int j) { int o = __p.__offset(8); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int BaseDilationsLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetBaseDilationsBytes() { return __p.__vector_as_span<long>(8, 8); }
#else
  public ArraySegment<byte>? GetBaseDilationsBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public long[] GetBaseDilationsArray() { return __p.__vector_as_array<long>(8); }
  public long WindowDilations(int j) { int o = __p.__offset(10); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int WindowDilationsLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetWindowDilationsBytes() { return __p.__vector_as_span<long>(10, 8); }
#else
  public ArraySegment<byte>? GetWindowDilationsBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public long[] GetWindowDilationsArray() { return __p.__vector_as_array<long>(10); }
  public long Padding(int j) { int o = __p.__offset(12); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int PaddingLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetPaddingBytes() { return __p.__vector_as_span<long>(12, 8); }
#else
  public ArraySegment<byte>? GetPaddingBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public long[] GetPaddingArray() { return __p.__vector_as_array<long>(12); }
  public int BodySubgraphIndex { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloReduceWindowOptions> CreateStablehloReduceWindowOptions(FlatBufferBuilder builder,
      VectorOffset window_dimensionsOffset = default(VectorOffset),
      VectorOffset window_stridesOffset = default(VectorOffset),
      VectorOffset base_dilationsOffset = default(VectorOffset),
      VectorOffset window_dilationsOffset = default(VectorOffset),
      VectorOffset paddingOffset = default(VectorOffset),
      int body_subgraph_index = 0) {
    builder.StartTable(6);
    StablehloReduceWindowOptions.AddBodySubgraphIndex(builder, body_subgraph_index);
    StablehloReduceWindowOptions.AddPadding(builder, paddingOffset);
    StablehloReduceWindowOptions.AddWindowDilations(builder, window_dilationsOffset);
    StablehloReduceWindowOptions.AddBaseDilations(builder, base_dilationsOffset);
    StablehloReduceWindowOptions.AddWindowStrides(builder, window_stridesOffset);
    StablehloReduceWindowOptions.AddWindowDimensions(builder, window_dimensionsOffset);
    return StablehloReduceWindowOptions.EndStablehloReduceWindowOptions(builder);
  }

  public static void StartStablehloReduceWindowOptions(FlatBufferBuilder builder) { builder.StartTable(6); }
  public static void AddWindowDimensions(FlatBufferBuilder builder, VectorOffset windowDimensionsOffset) { builder.AddOffset(0, windowDimensionsOffset.Value, 0); }
  public static VectorOffset CreateWindowDimensionsVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateWindowDimensionsVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateWindowDimensionsVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateWindowDimensionsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartWindowDimensionsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddWindowStrides(FlatBufferBuilder builder, VectorOffset windowStridesOffset) { builder.AddOffset(1, windowStridesOffset.Value, 0); }
  public static VectorOffset CreateWindowStridesVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateWindowStridesVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateWindowStridesVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateWindowStridesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartWindowStridesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddBaseDilations(FlatBufferBuilder builder, VectorOffset baseDilationsOffset) { builder.AddOffset(2, baseDilationsOffset.Value, 0); }
  public static VectorOffset CreateBaseDilationsVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateBaseDilationsVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBaseDilationsVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBaseDilationsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartBaseDilationsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddWindowDilations(FlatBufferBuilder builder, VectorOffset windowDilationsOffset) { builder.AddOffset(3, windowDilationsOffset.Value, 0); }
  public static VectorOffset CreateWindowDilationsVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateWindowDilationsVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateWindowDilationsVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateWindowDilationsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartWindowDilationsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddPadding(FlatBufferBuilder builder, VectorOffset paddingOffset) { builder.AddOffset(4, paddingOffset.Value, 0); }
  public static VectorOffset CreatePaddingVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreatePaddingVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePaddingVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePaddingVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPaddingVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddBodySubgraphIndex(FlatBufferBuilder builder, int bodySubgraphIndex) { builder.AddInt(5, bodySubgraphIndex, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloReduceWindowOptions> EndStablehloReduceWindowOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloReduceWindowOptions>(o);
  }
}


static class StablehloReduceWindowOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*WindowDimensions*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 6 /*WindowStrides*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 8 /*BaseDilations*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 10 /*WindowDilations*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 12 /*Padding*/, 8 /*long*/, false)
      && verifier.VerifyField(tablePos, 14 /*BodySubgraphIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloWhileOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloWhileOptions GetRootAsStablehloWhileOptions(ByteBuffer _bb) { return GetRootAsStablehloWhileOptions(_bb, new StablehloWhileOptions()); }
  public static StablehloWhileOptions GetRootAsStablehloWhileOptions(ByteBuffer _bb, StablehloWhileOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloWhileOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int CondSubgraphIndex { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int BodySubgraphIndex { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloWhileOptions> CreateStablehloWhileOptions(FlatBufferBuilder builder,
      int cond_subgraph_index = 0,
      int body_subgraph_index = 0) {
    builder.StartTable(2);
    StablehloWhileOptions.AddBodySubgraphIndex(builder, body_subgraph_index);
    StablehloWhileOptions.AddCondSubgraphIndex(builder, cond_subgraph_index);
    return StablehloWhileOptions.EndStablehloWhileOptions(builder);
  }

  public static void StartStablehloWhileOptions(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddCondSubgraphIndex(FlatBufferBuilder builder, int condSubgraphIndex) { builder.AddInt(0, condSubgraphIndex, 0); }
  public static void AddBodySubgraphIndex(FlatBufferBuilder builder, int bodySubgraphIndex) { builder.AddInt(1, bodySubgraphIndex, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloWhileOptions> EndStablehloWhileOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloWhileOptions>(o);
  }
}


static class StablehloWhileOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*CondSubgraphIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*BodySubgraphIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloSortOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloSortOptions GetRootAsStablehloSortOptions(ByteBuffer _bb) { return GetRootAsStablehloSortOptions(_bb, new StablehloSortOptions()); }
  public static StablehloSortOptions GetRootAsStablehloSortOptions(ByteBuffer _bb, StablehloSortOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloSortOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public long Dimension { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public bool IsStable { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public int ComparatorSubgraphIndex { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloSortOptions> CreateStablehloSortOptions(FlatBufferBuilder builder,
      long dimension = 0,
      bool is_stable = false,
      int comparator_subgraph_index = 0) {
    builder.StartTable(3);
    StablehloSortOptions.AddDimension(builder, dimension);
    StablehloSortOptions.AddComparatorSubgraphIndex(builder, comparator_subgraph_index);
    StablehloSortOptions.AddIsStable(builder, is_stable);
    return StablehloSortOptions.EndStablehloSortOptions(builder);
  }

  public static void StartStablehloSortOptions(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddDimension(FlatBufferBuilder builder, long dimension) { builder.AddLong(0, dimension, 0); }
  public static void AddIsStable(FlatBufferBuilder builder, bool isStable) { builder.AddBool(1, isStable, false); }
  public static void AddComparatorSubgraphIndex(FlatBufferBuilder builder, int comparatorSubgraphIndex) { builder.AddInt(2, comparatorSubgraphIndex, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloSortOptions> EndStablehloSortOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloSortOptions>(o);
  }
}


static class StablehloSortOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Dimension*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 6 /*IsStable*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 8 /*ComparatorSubgraphIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloConcatenateOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloConcatenateOptions GetRootAsStablehloConcatenateOptions(ByteBuffer _bb) { return GetRootAsStablehloConcatenateOptions(_bb, new StablehloConcatenateOptions()); }
  public static StablehloConcatenateOptions GetRootAsStablehloConcatenateOptions(ByteBuffer _bb, StablehloConcatenateOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloConcatenateOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public long Dimension { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloConcatenateOptions> CreateStablehloConcatenateOptions(FlatBufferBuilder builder,
      long dimension = 0) {
    builder.StartTable(1);
    StablehloConcatenateOptions.AddDimension(builder, dimension);
    return StablehloConcatenateOptions.EndStablehloConcatenateOptions(builder);
  }

  public static void StartStablehloConcatenateOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddDimension(FlatBufferBuilder builder, long dimension) { builder.AddLong(0, dimension, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloConcatenateOptions> EndStablehloConcatenateOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloConcatenateOptions>(o);
  }
}


static class StablehloConcatenateOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Dimension*/, 8 /*long*/, 8, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloBroadcastInDimOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloBroadcastInDimOptions GetRootAsStablehloBroadcastInDimOptions(ByteBuffer _bb) { return GetRootAsStablehloBroadcastInDimOptions(_bb, new StablehloBroadcastInDimOptions()); }
  public static StablehloBroadcastInDimOptions GetRootAsStablehloBroadcastInDimOptions(ByteBuffer _bb, StablehloBroadcastInDimOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloBroadcastInDimOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public long BroadcastDimensions(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int BroadcastDimensionsLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetBroadcastDimensionsBytes() { return __p.__vector_as_span<long>(4, 8); }
#else
  public ArraySegment<byte>? GetBroadcastDimensionsBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public long[] GetBroadcastDimensionsArray() { return __p.__vector_as_array<long>(4); }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloBroadcastInDimOptions> CreateStablehloBroadcastInDimOptions(FlatBufferBuilder builder,
      VectorOffset broadcast_dimensionsOffset = default(VectorOffset)) {
    builder.StartTable(1);
    StablehloBroadcastInDimOptions.AddBroadcastDimensions(builder, broadcast_dimensionsOffset);
    return StablehloBroadcastInDimOptions.EndStablehloBroadcastInDimOptions(builder);
  }

  public static void StartStablehloBroadcastInDimOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddBroadcastDimensions(FlatBufferBuilder builder, VectorOffset broadcastDimensionsOffset) { builder.AddOffset(0, broadcastDimensionsOffset.Value, 0); }
  public static VectorOffset CreateBroadcastDimensionsVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateBroadcastDimensionsVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBroadcastDimensionsVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBroadcastDimensionsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartBroadcastDimensionsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloBroadcastInDimOptions> EndStablehloBroadcastInDimOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloBroadcastInDimOptions>(o);
  }
}


static class StablehloBroadcastInDimOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*BroadcastDimensions*/, 8 /*long*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloCompareOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloCompareOptions GetRootAsStablehloCompareOptions(ByteBuffer _bb) { return GetRootAsStablehloCompareOptions(_bb, new StablehloCompareOptions()); }
  public static StablehloCompareOptions GetRootAsStablehloCompareOptions(ByteBuffer _bb, StablehloCompareOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloCompareOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.StablehloComparisonDirection ComparisonDirection { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.StablehloComparisonDirection)__p.bb.GetUint(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.StablehloComparisonDirection.STABLEHLO_COMPARISON_DIRECTION_EQ; } }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloComparisonType CompareType { get { int o = __p.__offset(6); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.StablehloComparisonType)__p.bb.GetUint(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.StablehloComparisonType.STABLEHLO_COMPARISON_TYPE_NOTYPE; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloCompareOptions> CreateStablehloCompareOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.StablehloComparisonDirection comparison_direction = Unity.InferenceEngine.Editor.LiteRT.StablehloComparisonDirection.STABLEHLO_COMPARISON_DIRECTION_EQ,
      Unity.InferenceEngine.Editor.LiteRT.StablehloComparisonType compare_type = Unity.InferenceEngine.Editor.LiteRT.StablehloComparisonType.STABLEHLO_COMPARISON_TYPE_NOTYPE) {
    builder.StartTable(2);
    StablehloCompareOptions.AddCompareType(builder, compare_type);
    StablehloCompareOptions.AddComparisonDirection(builder, comparison_direction);
    return StablehloCompareOptions.EndStablehloCompareOptions(builder);
  }

  public static void StartStablehloCompareOptions(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddComparisonDirection(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.StablehloComparisonDirection comparisonDirection) { builder.AddUint(0, (uint)comparisonDirection, 0); }
  public static void AddCompareType(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.StablehloComparisonType compareType) { builder.AddUint(1, (uint)compareType, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloCompareOptions> EndStablehloCompareOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloCompareOptions>(o);
  }
}


static class StablehloCompareOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*ComparisonDirection*/, 4 /*Unity.InferenceEngine.Editor.LiteRT.StablehloComparisonDirection*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*CompareType*/, 4 /*Unity.InferenceEngine.Editor.LiteRT.StablehloComparisonType*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloDynamicSliceOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloDynamicSliceOptions GetRootAsStablehloDynamicSliceOptions(ByteBuffer _bb) { return GetRootAsStablehloDynamicSliceOptions(_bb, new StablehloDynamicSliceOptions()); }
  public static StablehloDynamicSliceOptions GetRootAsStablehloDynamicSliceOptions(ByteBuffer _bb, StablehloDynamicSliceOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloDynamicSliceOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public long SliceSizes(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int SliceSizesLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetSliceSizesBytes() { return __p.__vector_as_span<long>(4, 8); }
#else
  public ArraySegment<byte>? GetSliceSizesBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public long[] GetSliceSizesArray() { return __p.__vector_as_array<long>(4); }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloDynamicSliceOptions> CreateStablehloDynamicSliceOptions(FlatBufferBuilder builder,
      VectorOffset slice_sizesOffset = default(VectorOffset)) {
    builder.StartTable(1);
    StablehloDynamicSliceOptions.AddSliceSizes(builder, slice_sizesOffset);
    return StablehloDynamicSliceOptions.EndStablehloDynamicSliceOptions(builder);
  }

  public static void StartStablehloDynamicSliceOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddSliceSizes(FlatBufferBuilder builder, VectorOffset sliceSizesOffset) { builder.AddOffset(0, sliceSizesOffset.Value, 0); }
  public static VectorOffset CreateSliceSizesVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateSliceSizesVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSliceSizesVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSliceSizesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSliceSizesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloDynamicSliceOptions> EndStablehloDynamicSliceOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloDynamicSliceOptions>(o);
  }
}


static class StablehloDynamicSliceOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*SliceSizes*/, 8 /*long*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloPadOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloPadOptions GetRootAsStablehloPadOptions(ByteBuffer _bb) { return GetRootAsStablehloPadOptions(_bb, new StablehloPadOptions()); }
  public static StablehloPadOptions GetRootAsStablehloPadOptions(ByteBuffer _bb, StablehloPadOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloPadOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public long EdgePaddingLow(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int EdgePaddingLowLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetEdgePaddingLowBytes() { return __p.__vector_as_span<long>(4, 8); }
#else
  public ArraySegment<byte>? GetEdgePaddingLowBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public long[] GetEdgePaddingLowArray() { return __p.__vector_as_array<long>(4); }
  public long EdgePaddingHigh(int j) { int o = __p.__offset(6); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int EdgePaddingHighLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetEdgePaddingHighBytes() { return __p.__vector_as_span<long>(6, 8); }
#else
  public ArraySegment<byte>? GetEdgePaddingHighBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public long[] GetEdgePaddingHighArray() { return __p.__vector_as_array<long>(6); }
  public long InteriorPadding(int j) { int o = __p.__offset(8); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int InteriorPaddingLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetInteriorPaddingBytes() { return __p.__vector_as_span<long>(8, 8); }
#else
  public ArraySegment<byte>? GetInteriorPaddingBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public long[] GetInteriorPaddingArray() { return __p.__vector_as_array<long>(8); }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloPadOptions> CreateStablehloPadOptions(FlatBufferBuilder builder,
      VectorOffset edge_padding_lowOffset = default(VectorOffset),
      VectorOffset edge_padding_highOffset = default(VectorOffset),
      VectorOffset interior_paddingOffset = default(VectorOffset)) {
    builder.StartTable(3);
    StablehloPadOptions.AddInteriorPadding(builder, interior_paddingOffset);
    StablehloPadOptions.AddEdgePaddingHigh(builder, edge_padding_highOffset);
    StablehloPadOptions.AddEdgePaddingLow(builder, edge_padding_lowOffset);
    return StablehloPadOptions.EndStablehloPadOptions(builder);
  }

  public static void StartStablehloPadOptions(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddEdgePaddingLow(FlatBufferBuilder builder, VectorOffset edgePaddingLowOffset) { builder.AddOffset(0, edgePaddingLowOffset.Value, 0); }
  public static VectorOffset CreateEdgePaddingLowVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateEdgePaddingLowVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateEdgePaddingLowVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateEdgePaddingLowVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartEdgePaddingLowVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddEdgePaddingHigh(FlatBufferBuilder builder, VectorOffset edgePaddingHighOffset) { builder.AddOffset(1, edgePaddingHighOffset.Value, 0); }
  public static VectorOffset CreateEdgePaddingHighVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateEdgePaddingHighVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateEdgePaddingHighVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateEdgePaddingHighVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartEdgePaddingHighVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddInteriorPadding(FlatBufferBuilder builder, VectorOffset interiorPaddingOffset) { builder.AddOffset(2, interiorPaddingOffset.Value, 0); }
  public static VectorOffset CreateInteriorPaddingVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateInteriorPaddingVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateInteriorPaddingVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateInteriorPaddingVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartInteriorPaddingVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloPadOptions> EndStablehloPadOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloPadOptions>(o);
  }
}


static class StablehloPadOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*EdgePaddingLow*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 6 /*EdgePaddingHigh*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 8 /*InteriorPadding*/, 8 /*long*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloIotaOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloIotaOptions GetRootAsStablehloIotaOptions(ByteBuffer _bb) { return GetRootAsStablehloIotaOptions(_bb, new StablehloIotaOptions()); }
  public static StablehloIotaOptions GetRootAsStablehloIotaOptions(ByteBuffer _bb, StablehloIotaOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloIotaOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public long IotaDimension { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloIotaOptions> CreateStablehloIotaOptions(FlatBufferBuilder builder,
      long iota_dimension = 0) {
    builder.StartTable(1);
    StablehloIotaOptions.AddIotaDimension(builder, iota_dimension);
    return StablehloIotaOptions.EndStablehloIotaOptions(builder);
  }

  public static void StartStablehloIotaOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddIotaDimension(FlatBufferBuilder builder, long iotaDimension) { builder.AddLong(0, iotaDimension, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloIotaOptions> EndStablehloIotaOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloIotaOptions>(o);
  }
}


static class StablehloIotaOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*IotaDimension*/, 8 /*long*/, 8, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloCustomCallOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloCustomCallOptions GetRootAsStablehloCustomCallOptions(ByteBuffer _bb) { return GetRootAsStablehloCustomCallOptions(_bb, new StablehloCustomCallOptions()); }
  public static StablehloCustomCallOptions GetRootAsStablehloCustomCallOptions(ByteBuffer _bb, StablehloCustomCallOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloCustomCallOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string CallTargetName { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCallTargetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetCallTargetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetCallTargetNameArray() { return __p.__vector_as_array<byte>(4); }
  public bool HasSideEffect { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public string BackendConfig { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetBackendConfigBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetBackendConfigBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetBackendConfigArray() { return __p.__vector_as_array<byte>(8); }
  public int ApiVersion { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int CalledComputations(int j) { int o = __p.__offset(12); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int CalledComputationsLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetCalledComputationsBytes() { return __p.__vector_as_span<int>(12, 4); }
#else
  public ArraySegment<byte>? GetCalledComputationsBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public int[] GetCalledComputationsArray() { return __p.__vector_as_array<int>(12); }
  public byte CustomAttributes(int j) { int o = __p.__offset(14); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int CustomAttributesLength { get { int o = __p.__offset(14); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCustomAttributesBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetCustomAttributesBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetCustomAttributesArray() { return __p.__vector_as_array<byte>(14); }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloCustomCallOptions> CreateStablehloCustomCallOptions(FlatBufferBuilder builder,
      StringOffset call_target_nameOffset = default(StringOffset),
      bool has_side_effect = false,
      StringOffset backend_configOffset = default(StringOffset),
      int api_version = 0,
      VectorOffset called_computationsOffset = default(VectorOffset),
      VectorOffset custom_attributesOffset = default(VectorOffset)) {
    builder.StartTable(6);
    StablehloCustomCallOptions.AddCustomAttributes(builder, custom_attributesOffset);
    StablehloCustomCallOptions.AddCalledComputations(builder, called_computationsOffset);
    StablehloCustomCallOptions.AddApiVersion(builder, api_version);
    StablehloCustomCallOptions.AddBackendConfig(builder, backend_configOffset);
    StablehloCustomCallOptions.AddCallTargetName(builder, call_target_nameOffset);
    StablehloCustomCallOptions.AddHasSideEffect(builder, has_side_effect);
    return StablehloCustomCallOptions.EndStablehloCustomCallOptions(builder);
  }

  public static void StartStablehloCustomCallOptions(FlatBufferBuilder builder) { builder.StartTable(6); }
  public static void AddCallTargetName(FlatBufferBuilder builder, StringOffset callTargetNameOffset) { builder.AddOffset(0, callTargetNameOffset.Value, 0); }
  public static void AddHasSideEffect(FlatBufferBuilder builder, bool hasSideEffect) { builder.AddBool(1, hasSideEffect, false); }
  public static void AddBackendConfig(FlatBufferBuilder builder, StringOffset backendConfigOffset) { builder.AddOffset(2, backendConfigOffset.Value, 0); }
  public static void AddApiVersion(FlatBufferBuilder builder, int apiVersion) { builder.AddInt(3, apiVersion, 0); }
  public static void AddCalledComputations(FlatBufferBuilder builder, VectorOffset calledComputationsOffset) { builder.AddOffset(4, calledComputationsOffset.Value, 0); }
  public static VectorOffset CreateCalledComputationsVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateCalledComputationsVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCalledComputationsVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCalledComputationsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCalledComputationsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddCustomAttributes(FlatBufferBuilder builder, VectorOffset customAttributesOffset) { builder.AddOffset(5, customAttributesOffset.Value, 0); }
  public static VectorOffset CreateCustomAttributesVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateCustomAttributesVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCustomAttributesVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCustomAttributesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCustomAttributesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloCustomCallOptions> EndStablehloCustomCallOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloCustomCallOptions>(o);
  }
}


static class StablehloCustomCallOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*CallTargetName*/, false)
      && verifier.VerifyField(tablePos, 6 /*HasSideEffect*/, 1 /*bool*/, 1, false)
      && verifier.VerifyString(tablePos, 8 /*BackendConfig*/, false)
      && verifier.VerifyField(tablePos, 10 /*ApiVersion*/, 4 /*int*/, 4, false)
      && verifier.VerifyVectorOfData(tablePos, 12 /*CalledComputations*/, 4 /*int*/, false)
      && verifier.VerifyVectorOfData(tablePos, 14 /*CustomAttributes*/, 1 /*byte*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloReduceOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloReduceOptions GetRootAsStablehloReduceOptions(ByteBuffer _bb) { return GetRootAsStablehloReduceOptions(_bb, new StablehloReduceOptions()); }
  public static StablehloReduceOptions GetRootAsStablehloReduceOptions(ByteBuffer _bb, StablehloReduceOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloReduceOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public long Dimensions(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int DimensionsLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetDimensionsBytes() { return __p.__vector_as_span<long>(4, 8); }
#else
  public ArraySegment<byte>? GetDimensionsBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public long[] GetDimensionsArray() { return __p.__vector_as_array<long>(4); }
  public int BodySubgraphIndex { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloReduceOptions> CreateStablehloReduceOptions(FlatBufferBuilder builder,
      VectorOffset dimensionsOffset = default(VectorOffset),
      int body_subgraph_index = 0) {
    builder.StartTable(2);
    StablehloReduceOptions.AddBodySubgraphIndex(builder, body_subgraph_index);
    StablehloReduceOptions.AddDimensions(builder, dimensionsOffset);
    return StablehloReduceOptions.EndStablehloReduceOptions(builder);
  }

  public static void StartStablehloReduceOptions(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddDimensions(FlatBufferBuilder builder, VectorOffset dimensionsOffset) { builder.AddOffset(0, dimensionsOffset.Value, 0); }
  public static VectorOffset CreateDimensionsVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateDimensionsVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateDimensionsVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateDimensionsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartDimensionsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddBodySubgraphIndex(FlatBufferBuilder builder, int bodySubgraphIndex) { builder.AddInt(1, bodySubgraphIndex, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloReduceOptions> EndStablehloReduceOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloReduceOptions>(o);
  }
}


static class StablehloReduceOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*Dimensions*/, 8 /*long*/, false)
      && verifier.VerifyField(tablePos, 6 /*BodySubgraphIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloSliceOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloSliceOptions GetRootAsStablehloSliceOptions(ByteBuffer _bb) { return GetRootAsStablehloSliceOptions(_bb, new StablehloSliceOptions()); }
  public static StablehloSliceOptions GetRootAsStablehloSliceOptions(ByteBuffer _bb, StablehloSliceOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloSliceOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public long StartIndices(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int StartIndicesLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetStartIndicesBytes() { return __p.__vector_as_span<long>(4, 8); }
#else
  public ArraySegment<byte>? GetStartIndicesBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public long[] GetStartIndicesArray() { return __p.__vector_as_array<long>(4); }
  public long LimitIndices(int j) { int o = __p.__offset(6); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int LimitIndicesLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetLimitIndicesBytes() { return __p.__vector_as_span<long>(6, 8); }
#else
  public ArraySegment<byte>? GetLimitIndicesBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public long[] GetLimitIndicesArray() { return __p.__vector_as_array<long>(6); }
  public long Strides(int j) { int o = __p.__offset(8); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int StridesLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetStridesBytes() { return __p.__vector_as_span<long>(8, 8); }
#else
  public ArraySegment<byte>? GetStridesBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public long[] GetStridesArray() { return __p.__vector_as_array<long>(8); }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloSliceOptions> CreateStablehloSliceOptions(FlatBufferBuilder builder,
      VectorOffset start_indicesOffset = default(VectorOffset),
      VectorOffset limit_indicesOffset = default(VectorOffset),
      VectorOffset stridesOffset = default(VectorOffset)) {
    builder.StartTable(3);
    StablehloSliceOptions.AddStrides(builder, stridesOffset);
    StablehloSliceOptions.AddLimitIndices(builder, limit_indicesOffset);
    StablehloSliceOptions.AddStartIndices(builder, start_indicesOffset);
    return StablehloSliceOptions.EndStablehloSliceOptions(builder);
  }

  public static void StartStablehloSliceOptions(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddStartIndices(FlatBufferBuilder builder, VectorOffset startIndicesOffset) { builder.AddOffset(0, startIndicesOffset.Value, 0); }
  public static VectorOffset CreateStartIndicesVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateStartIndicesVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateStartIndicesVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateStartIndicesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartStartIndicesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddLimitIndices(FlatBufferBuilder builder, VectorOffset limitIndicesOffset) { builder.AddOffset(1, limitIndicesOffset.Value, 0); }
  public static VectorOffset CreateLimitIndicesVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateLimitIndicesVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLimitIndicesVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLimitIndicesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartLimitIndicesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddStrides(FlatBufferBuilder builder, VectorOffset stridesOffset) { builder.AddOffset(2, stridesOffset.Value, 0); }
  public static VectorOffset CreateStridesVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateStridesVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateStridesVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateStridesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartStridesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloSliceOptions> EndStablehloSliceOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloSliceOptions>(o);
  }
}


static class StablehloSliceOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*StartIndices*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 6 /*LimitIndices*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 8 /*Strides*/, 8 /*long*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloConvolutionOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloConvolutionOptions GetRootAsStablehloConvolutionOptions(ByteBuffer _bb) { return GetRootAsStablehloConvolutionOptions(_bb, new StablehloConvolutionOptions()); }
  public static StablehloConvolutionOptions GetRootAsStablehloConvolutionOptions(ByteBuffer _bb, StablehloConvolutionOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloConvolutionOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public long WindowStrides(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int WindowStridesLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetWindowStridesBytes() { return __p.__vector_as_span<long>(4, 8); }
#else
  public ArraySegment<byte>? GetWindowStridesBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public long[] GetWindowStridesArray() { return __p.__vector_as_array<long>(4); }
  public long Padding(int j) { int o = __p.__offset(6); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int PaddingLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetPaddingBytes() { return __p.__vector_as_span<long>(6, 8); }
#else
  public ArraySegment<byte>? GetPaddingBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public long[] GetPaddingArray() { return __p.__vector_as_array<long>(6); }
  public long LhsDilation(int j) { int o = __p.__offset(8); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int LhsDilationLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetLhsDilationBytes() { return __p.__vector_as_span<long>(8, 8); }
#else
  public ArraySegment<byte>? GetLhsDilationBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public long[] GetLhsDilationArray() { return __p.__vector_as_array<long>(8); }
  public long RhsDilation(int j) { int o = __p.__offset(10); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int RhsDilationLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetRhsDilationBytes() { return __p.__vector_as_span<long>(10, 8); }
#else
  public ArraySegment<byte>? GetRhsDilationBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public long[] GetRhsDilationArray() { return __p.__vector_as_array<long>(10); }
  public bool WindowReversal(int j) { int o = __p.__offset(12); return o != 0 ? 0!=__p.bb.Get(__p.__vector(o) + j * 1) : false; }
  public int WindowReversalLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<bool> GetWindowReversalBytes() { return __p.__vector_as_span<bool>(12, 1); }
#else
  public ArraySegment<byte>? GetWindowReversalBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public bool[] GetWindowReversalArray() { return __p.__vector_as_array<bool>(12); }
  public long InputBatchDimension { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public long InputFeatureDimension { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public long InputSpatialDimensions(int j) { int o = __p.__offset(18); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int InputSpatialDimensionsLength { get { int o = __p.__offset(18); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetInputSpatialDimensionsBytes() { return __p.__vector_as_span<long>(18, 8); }
#else
  public ArraySegment<byte>? GetInputSpatialDimensionsBytes() { return __p.__vector_as_arraysegment(18); }
#endif
  public long[] GetInputSpatialDimensionsArray() { return __p.__vector_as_array<long>(18); }
  public long KernelInputFeatureDimension { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public long KernelOutputFeatureDimension { get { int o = __p.__offset(22); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public long KernelSpatialDimensions(int j) { int o = __p.__offset(24); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int KernelSpatialDimensionsLength { get { int o = __p.__offset(24); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetKernelSpatialDimensionsBytes() { return __p.__vector_as_span<long>(24, 8); }
#else
  public ArraySegment<byte>? GetKernelSpatialDimensionsBytes() { return __p.__vector_as_arraysegment(24); }
#endif
  public long[] GetKernelSpatialDimensionsArray() { return __p.__vector_as_array<long>(24); }
  public long OutputBatchDimension { get { int o = __p.__offset(26); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public long OutputFeatureDimension { get { int o = __p.__offset(28); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public long OutputSpatialDimensions(int j) { int o = __p.__offset(30); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int OutputSpatialDimensionsLength { get { int o = __p.__offset(30); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetOutputSpatialDimensionsBytes() { return __p.__vector_as_span<long>(30, 8); }
#else
  public ArraySegment<byte>? GetOutputSpatialDimensionsBytes() { return __p.__vector_as_arraysegment(30); }
#endif
  public long[] GetOutputSpatialDimensionsArray() { return __p.__vector_as_array<long>(30); }
  public long FeatureGroupCount { get { int o = __p.__offset(32); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public long BatchGroupCount { get { int o = __p.__offset(34); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig PrecisionConfig(int j) { int o = __p.__offset(36); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig)__p.bb.GetUint(__p.__vector(o) + j * 4) : (Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig)0; }
  public int PrecisionConfigLength { get { int o = __p.__offset(36); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig> GetPrecisionConfigBytes() { return __p.__vector_as_span<Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig>(36, 4); }
#else
  public ArraySegment<byte>? GetPrecisionConfigBytes() { return __p.__vector_as_arraysegment(36); }
#endif
  public Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig[] GetPrecisionConfigArray() { int o = __p.__offset(36); if (o == 0) return null; int p = __p.__vector(o); int l = __p.__vector_len(o); Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig[] a = new Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig[l]; for (int i = 0; i < l; i++) { a[i] = (Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig)__p.bb.GetUint(p + i * 4); } return a; }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloConvolutionOptions> CreateStablehloConvolutionOptions(FlatBufferBuilder builder,
      VectorOffset window_stridesOffset = default(VectorOffset),
      VectorOffset paddingOffset = default(VectorOffset),
      VectorOffset lhs_dilationOffset = default(VectorOffset),
      VectorOffset rhs_dilationOffset = default(VectorOffset),
      VectorOffset window_reversalOffset = default(VectorOffset),
      long input_batch_dimension = 0,
      long input_feature_dimension = 0,
      VectorOffset input_spatial_dimensionsOffset = default(VectorOffset),
      long kernel_input_feature_dimension = 0,
      long kernel_output_feature_dimension = 0,
      VectorOffset kernel_spatial_dimensionsOffset = default(VectorOffset),
      long output_batch_dimension = 0,
      long output_feature_dimension = 0,
      VectorOffset output_spatial_dimensionsOffset = default(VectorOffset),
      long feature_group_count = 0,
      long batch_group_count = 0,
      VectorOffset precision_configOffset = default(VectorOffset)) {
    builder.StartTable(17);
    StablehloConvolutionOptions.AddBatchGroupCount(builder, batch_group_count);
    StablehloConvolutionOptions.AddFeatureGroupCount(builder, feature_group_count);
    StablehloConvolutionOptions.AddOutputFeatureDimension(builder, output_feature_dimension);
    StablehloConvolutionOptions.AddOutputBatchDimension(builder, output_batch_dimension);
    StablehloConvolutionOptions.AddKernelOutputFeatureDimension(builder, kernel_output_feature_dimension);
    StablehloConvolutionOptions.AddKernelInputFeatureDimension(builder, kernel_input_feature_dimension);
    StablehloConvolutionOptions.AddInputFeatureDimension(builder, input_feature_dimension);
    StablehloConvolutionOptions.AddInputBatchDimension(builder, input_batch_dimension);
    StablehloConvolutionOptions.AddPrecisionConfig(builder, precision_configOffset);
    StablehloConvolutionOptions.AddOutputSpatialDimensions(builder, output_spatial_dimensionsOffset);
    StablehloConvolutionOptions.AddKernelSpatialDimensions(builder, kernel_spatial_dimensionsOffset);
    StablehloConvolutionOptions.AddInputSpatialDimensions(builder, input_spatial_dimensionsOffset);
    StablehloConvolutionOptions.AddWindowReversal(builder, window_reversalOffset);
    StablehloConvolutionOptions.AddRhsDilation(builder, rhs_dilationOffset);
    StablehloConvolutionOptions.AddLhsDilation(builder, lhs_dilationOffset);
    StablehloConvolutionOptions.AddPadding(builder, paddingOffset);
    StablehloConvolutionOptions.AddWindowStrides(builder, window_stridesOffset);
    return StablehloConvolutionOptions.EndStablehloConvolutionOptions(builder);
  }

  public static void StartStablehloConvolutionOptions(FlatBufferBuilder builder) { builder.StartTable(17); }
  public static void AddWindowStrides(FlatBufferBuilder builder, VectorOffset windowStridesOffset) { builder.AddOffset(0, windowStridesOffset.Value, 0); }
  public static VectorOffset CreateWindowStridesVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateWindowStridesVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateWindowStridesVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateWindowStridesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartWindowStridesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddPadding(FlatBufferBuilder builder, VectorOffset paddingOffset) { builder.AddOffset(1, paddingOffset.Value, 0); }
  public static VectorOffset CreatePaddingVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreatePaddingVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePaddingVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePaddingVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPaddingVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddLhsDilation(FlatBufferBuilder builder, VectorOffset lhsDilationOffset) { builder.AddOffset(2, lhsDilationOffset.Value, 0); }
  public static VectorOffset CreateLhsDilationVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateLhsDilationVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLhsDilationVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLhsDilationVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartLhsDilationVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddRhsDilation(FlatBufferBuilder builder, VectorOffset rhsDilationOffset) { builder.AddOffset(3, rhsDilationOffset.Value, 0); }
  public static VectorOffset CreateRhsDilationVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateRhsDilationVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRhsDilationVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRhsDilationVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartRhsDilationVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddWindowReversal(FlatBufferBuilder builder, VectorOffset windowReversalOffset) { builder.AddOffset(4, windowReversalOffset.Value, 0); }
  public static VectorOffset CreateWindowReversalVector(FlatBufferBuilder builder, bool[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddBool(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateWindowReversalVectorBlock(FlatBufferBuilder builder, bool[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateWindowReversalVectorBlock(FlatBufferBuilder builder, ArraySegment<bool> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateWindowReversalVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<bool>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartWindowReversalVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddInputBatchDimension(FlatBufferBuilder builder, long inputBatchDimension) { builder.AddLong(5, inputBatchDimension, 0); }
  public static void AddInputFeatureDimension(FlatBufferBuilder builder, long inputFeatureDimension) { builder.AddLong(6, inputFeatureDimension, 0); }
  public static void AddInputSpatialDimensions(FlatBufferBuilder builder, VectorOffset inputSpatialDimensionsOffset) { builder.AddOffset(7, inputSpatialDimensionsOffset.Value, 0); }
  public static VectorOffset CreateInputSpatialDimensionsVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateInputSpatialDimensionsVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateInputSpatialDimensionsVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateInputSpatialDimensionsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartInputSpatialDimensionsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddKernelInputFeatureDimension(FlatBufferBuilder builder, long kernelInputFeatureDimension) { builder.AddLong(8, kernelInputFeatureDimension, 0); }
  public static void AddKernelOutputFeatureDimension(FlatBufferBuilder builder, long kernelOutputFeatureDimension) { builder.AddLong(9, kernelOutputFeatureDimension, 0); }
  public static void AddKernelSpatialDimensions(FlatBufferBuilder builder, VectorOffset kernelSpatialDimensionsOffset) { builder.AddOffset(10, kernelSpatialDimensionsOffset.Value, 0); }
  public static VectorOffset CreateKernelSpatialDimensionsVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateKernelSpatialDimensionsVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateKernelSpatialDimensionsVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateKernelSpatialDimensionsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartKernelSpatialDimensionsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddOutputBatchDimension(FlatBufferBuilder builder, long outputBatchDimension) { builder.AddLong(11, outputBatchDimension, 0); }
  public static void AddOutputFeatureDimension(FlatBufferBuilder builder, long outputFeatureDimension) { builder.AddLong(12, outputFeatureDimension, 0); }
  public static void AddOutputSpatialDimensions(FlatBufferBuilder builder, VectorOffset outputSpatialDimensionsOffset) { builder.AddOffset(13, outputSpatialDimensionsOffset.Value, 0); }
  public static VectorOffset CreateOutputSpatialDimensionsVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateOutputSpatialDimensionsVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateOutputSpatialDimensionsVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateOutputSpatialDimensionsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartOutputSpatialDimensionsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddFeatureGroupCount(FlatBufferBuilder builder, long featureGroupCount) { builder.AddLong(14, featureGroupCount, 0); }
  public static void AddBatchGroupCount(FlatBufferBuilder builder, long batchGroupCount) { builder.AddLong(15, batchGroupCount, 0); }
  public static void AddPrecisionConfig(FlatBufferBuilder builder, VectorOffset precisionConfigOffset) { builder.AddOffset(16, precisionConfigOffset.Value, 0); }
  public static VectorOffset CreatePrecisionConfigVector(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddUint((uint)data[i]); return builder.EndVector(); }
  public static VectorOffset CreatePrecisionConfigVectorBlock(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePrecisionConfigVectorBlock(FlatBufferBuilder builder, ArraySegment<Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePrecisionConfigVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPrecisionConfigVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloConvolutionOptions> EndStablehloConvolutionOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloConvolutionOptions>(o);
  }
}


static class StablehloConvolutionOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*WindowStrides*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 6 /*Padding*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 8 /*LhsDilation*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 10 /*RhsDilation*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 12 /*WindowReversal*/, 1 /*bool*/, false)
      && verifier.VerifyField(tablePos, 14 /*InputBatchDimension*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 16 /*InputFeatureDimension*/, 8 /*long*/, 8, false)
      && verifier.VerifyVectorOfData(tablePos, 18 /*InputSpatialDimensions*/, 8 /*long*/, false)
      && verifier.VerifyField(tablePos, 20 /*KernelInputFeatureDimension*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 22 /*KernelOutputFeatureDimension*/, 8 /*long*/, 8, false)
      && verifier.VerifyVectorOfData(tablePos, 24 /*KernelSpatialDimensions*/, 8 /*long*/, false)
      && verifier.VerifyField(tablePos, 26 /*OutputBatchDimension*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 28 /*OutputFeatureDimension*/, 8 /*long*/, 8, false)
      && verifier.VerifyVectorOfData(tablePos, 30 /*OutputSpatialDimensions*/, 8 /*long*/, false)
      && verifier.VerifyField(tablePos, 32 /*FeatureGroupCount*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 34 /*BatchGroupCount*/, 8 /*long*/, 8, false)
      && verifier.VerifyVectorOfData(tablePos, 36 /*PrecisionConfig*/, 4 /*Unity.InferenceEngine.Editor.LiteRT.StablehloPrecisionConfig*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloScatterOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloScatterOptions GetRootAsStablehloScatterOptions(ByteBuffer _bb) { return GetRootAsStablehloScatterOptions(_bb, new StablehloScatterOptions()); }
  public static StablehloScatterOptions GetRootAsStablehloScatterOptions(ByteBuffer _bb, StablehloScatterOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloScatterOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool IndicesAreSorted { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public long UpdateWindowDims(int j) { int o = __p.__offset(6); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int UpdateWindowDimsLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetUpdateWindowDimsBytes() { return __p.__vector_as_span<long>(6, 8); }
#else
  public ArraySegment<byte>? GetUpdateWindowDimsBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public long[] GetUpdateWindowDimsArray() { return __p.__vector_as_array<long>(6); }
  public long InsertedWindowDims(int j) { int o = __p.__offset(8); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int InsertedWindowDimsLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetInsertedWindowDimsBytes() { return __p.__vector_as_span<long>(8, 8); }
#else
  public ArraySegment<byte>? GetInsertedWindowDimsBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public long[] GetInsertedWindowDimsArray() { return __p.__vector_as_array<long>(8); }
  public long ScatterDimsToOperandDims(int j) { int o = __p.__offset(10); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int ScatterDimsToOperandDimsLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetScatterDimsToOperandDimsBytes() { return __p.__vector_as_span<long>(10, 8); }
#else
  public ArraySegment<byte>? GetScatterDimsToOperandDimsBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public long[] GetScatterDimsToOperandDimsArray() { return __p.__vector_as_array<long>(10); }
  public long IndexVectorDim { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public bool UniqueIndices { get { int o = __p.__offset(14); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public int UpdateComputationSubgraphIndex { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloScatterOptions> CreateStablehloScatterOptions(FlatBufferBuilder builder,
      bool indices_are_sorted = false,
      VectorOffset update_window_dimsOffset = default(VectorOffset),
      VectorOffset inserted_window_dimsOffset = default(VectorOffset),
      VectorOffset scatter_dims_to_operand_dimsOffset = default(VectorOffset),
      long index_vector_dim = 0,
      bool unique_indices = false,
      int update_computation_subgraph_index = 0) {
    builder.StartTable(7);
    StablehloScatterOptions.AddIndexVectorDim(builder, index_vector_dim);
    StablehloScatterOptions.AddUpdateComputationSubgraphIndex(builder, update_computation_subgraph_index);
    StablehloScatterOptions.AddScatterDimsToOperandDims(builder, scatter_dims_to_operand_dimsOffset);
    StablehloScatterOptions.AddInsertedWindowDims(builder, inserted_window_dimsOffset);
    StablehloScatterOptions.AddUpdateWindowDims(builder, update_window_dimsOffset);
    StablehloScatterOptions.AddUniqueIndices(builder, unique_indices);
    StablehloScatterOptions.AddIndicesAreSorted(builder, indices_are_sorted);
    return StablehloScatterOptions.EndStablehloScatterOptions(builder);
  }

  public static void StartStablehloScatterOptions(FlatBufferBuilder builder) { builder.StartTable(7); }
  public static void AddIndicesAreSorted(FlatBufferBuilder builder, bool indicesAreSorted) { builder.AddBool(0, indicesAreSorted, false); }
  public static void AddUpdateWindowDims(FlatBufferBuilder builder, VectorOffset updateWindowDimsOffset) { builder.AddOffset(1, updateWindowDimsOffset.Value, 0); }
  public static VectorOffset CreateUpdateWindowDimsVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateUpdateWindowDimsVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateUpdateWindowDimsVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateUpdateWindowDimsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartUpdateWindowDimsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddInsertedWindowDims(FlatBufferBuilder builder, VectorOffset insertedWindowDimsOffset) { builder.AddOffset(2, insertedWindowDimsOffset.Value, 0); }
  public static VectorOffset CreateInsertedWindowDimsVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateInsertedWindowDimsVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateInsertedWindowDimsVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateInsertedWindowDimsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartInsertedWindowDimsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddScatterDimsToOperandDims(FlatBufferBuilder builder, VectorOffset scatterDimsToOperandDimsOffset) { builder.AddOffset(3, scatterDimsToOperandDimsOffset.Value, 0); }
  public static VectorOffset CreateScatterDimsToOperandDimsVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateScatterDimsToOperandDimsVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateScatterDimsToOperandDimsVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateScatterDimsToOperandDimsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartScatterDimsToOperandDimsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddIndexVectorDim(FlatBufferBuilder builder, long indexVectorDim) { builder.AddLong(4, indexVectorDim, 0); }
  public static void AddUniqueIndices(FlatBufferBuilder builder, bool uniqueIndices) { builder.AddBool(5, uniqueIndices, false); }
  public static void AddUpdateComputationSubgraphIndex(FlatBufferBuilder builder, int updateComputationSubgraphIndex) { builder.AddInt(6, updateComputationSubgraphIndex, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloScatterOptions> EndStablehloScatterOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloScatterOptions>(o);
  }
}


static class StablehloScatterOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*IndicesAreSorted*/, 1 /*bool*/, 1, false)
      && verifier.VerifyVectorOfData(tablePos, 6 /*UpdateWindowDims*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 8 /*InsertedWindowDims*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 10 /*ScatterDimsToOperandDims*/, 8 /*long*/, false)
      && verifier.VerifyField(tablePos, 12 /*IndexVectorDim*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 14 /*UniqueIndices*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 16 /*UpdateComputationSubgraphIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloCaseOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloCaseOptions GetRootAsStablehloCaseOptions(ByteBuffer _bb) { return GetRootAsStablehloCaseOptions(_bb, new StablehloCaseOptions()); }
  public static StablehloCaseOptions GetRootAsStablehloCaseOptions(ByteBuffer _bb, StablehloCaseOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloCaseOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int BranchSubgraphIndices(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int BranchSubgraphIndicesLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetBranchSubgraphIndicesBytes() { return __p.__vector_as_span<int>(4, 4); }
#else
  public ArraySegment<byte>? GetBranchSubgraphIndicesBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public int[] GetBranchSubgraphIndicesArray() { return __p.__vector_as_array<int>(4); }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloCaseOptions> CreateStablehloCaseOptions(FlatBufferBuilder builder,
      VectorOffset branch_subgraph_indicesOffset = default(VectorOffset)) {
    builder.StartTable(1);
    StablehloCaseOptions.AddBranchSubgraphIndices(builder, branch_subgraph_indicesOffset);
    return StablehloCaseOptions.EndStablehloCaseOptions(builder);
  }

  public static void StartStablehloCaseOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddBranchSubgraphIndices(FlatBufferBuilder builder, VectorOffset branchSubgraphIndicesOffset) { builder.AddOffset(0, branchSubgraphIndicesOffset.Value, 0); }
  public static VectorOffset CreateBranchSubgraphIndicesVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateBranchSubgraphIndicesVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBranchSubgraphIndicesVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBranchSubgraphIndicesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartBranchSubgraphIndicesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloCaseOptions> EndStablehloCaseOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloCaseOptions>(o);
  }
}


static class StablehloCaseOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*BranchSubgraphIndices*/, 4 /*int*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloRngBitGeneratorOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloRngBitGeneratorOptions GetRootAsStablehloRngBitGeneratorOptions(ByteBuffer _bb) { return GetRootAsStablehloRngBitGeneratorOptions(_bb, new StablehloRngBitGeneratorOptions()); }
  public static StablehloRngBitGeneratorOptions GetRootAsStablehloRngBitGeneratorOptions(ByteBuffer _bb, StablehloRngBitGeneratorOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloRngBitGeneratorOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.RngAlgorithm Algorithm { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.RngAlgorithm)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.RngAlgorithm.DEFAULT; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloRngBitGeneratorOptions> CreateStablehloRngBitGeneratorOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.RngAlgorithm algorithm = Unity.InferenceEngine.Editor.LiteRT.RngAlgorithm.DEFAULT) {
    builder.StartTable(1);
    StablehloRngBitGeneratorOptions.AddAlgorithm(builder, algorithm);
    return StablehloRngBitGeneratorOptions.EndStablehloRngBitGeneratorOptions(builder);
  }

  public static void StartStablehloRngBitGeneratorOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddAlgorithm(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.RngAlgorithm algorithm) { builder.AddSbyte(0, (sbyte)algorithm, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloRngBitGeneratorOptions> EndStablehloRngBitGeneratorOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloRngBitGeneratorOptions>(o);
  }
}


static class StablehloRngBitGeneratorOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Algorithm*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.RngAlgorithm*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct Conv2DOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static Conv2DOptions GetRootAsConv2DOptions(ByteBuffer _bb) { return GetRootAsConv2DOptions(_bb, new Conv2DOptions()); }
  public static Conv2DOptions GetRootAsConv2DOptions(ByteBuffer _bb, Conv2DOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Conv2DOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.Padding Padding { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.Padding)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.Padding.SAME; } }
  public int StrideW { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int StrideH { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType FusedActivationFunction { get { int o = __p.__offset(10); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE; } }
  public int DilationWFactor { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)1; } }
  public int DilationHFactor { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)1; } }
  public Unity.InferenceEngine.Editor.LiteRT.TensorType QuantizedBiasType { get { int o = __p.__offset(16); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.TensorType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Conv2DOptions> CreateConv2DOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.Padding padding = Unity.InferenceEngine.Editor.LiteRT.Padding.SAME,
      int stride_w = 0,
      int stride_h = 0,
      Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fused_activation_function = Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE,
      int dilation_w_factor = 1,
      int dilation_h_factor = 1,
      Unity.InferenceEngine.Editor.LiteRT.TensorType quantized_bias_type = Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32) {
    builder.StartTable(7);
    Conv2DOptions.AddDilationHFactor(builder, dilation_h_factor);
    Conv2DOptions.AddDilationWFactor(builder, dilation_w_factor);
    Conv2DOptions.AddStrideH(builder, stride_h);
    Conv2DOptions.AddStrideW(builder, stride_w);
    Conv2DOptions.AddQuantizedBiasType(builder, quantized_bias_type);
    Conv2DOptions.AddFusedActivationFunction(builder, fused_activation_function);
    Conv2DOptions.AddPadding(builder, padding);
    return Conv2DOptions.EndConv2DOptions(builder);
  }

  public static void StartConv2DOptions(FlatBufferBuilder builder) { builder.StartTable(7); }
  public static void AddPadding(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.Padding padding) { builder.AddSbyte(0, (sbyte)padding, 0); }
  public static void AddStrideW(FlatBufferBuilder builder, int strideW) { builder.AddInt(1, strideW, 0); }
  public static void AddStrideH(FlatBufferBuilder builder, int strideH) { builder.AddInt(2, strideH, 0); }
  public static void AddFusedActivationFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fusedActivationFunction) { builder.AddSbyte(3, (sbyte)fusedActivationFunction, 0); }
  public static void AddDilationWFactor(FlatBufferBuilder builder, int dilationWFactor) { builder.AddInt(4, dilationWFactor, 1); }
  public static void AddDilationHFactor(FlatBufferBuilder builder, int dilationHFactor) { builder.AddInt(5, dilationHFactor, 1); }
  public static void AddQuantizedBiasType(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.TensorType quantizedBiasType) { builder.AddSbyte(6, (sbyte)quantizedBiasType, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Conv2DOptions> EndConv2DOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.Conv2DOptions>(o);
  }
}


static class Conv2DOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Padding*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.Padding*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*StrideW*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*StrideH*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*FusedActivationFunction*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType*/, 1, false)
      && verifier.VerifyField(tablePos, 12 /*DilationWFactor*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 14 /*DilationHFactor*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 16 /*QuantizedBiasType*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.TensorType*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct Conv3DOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static Conv3DOptions GetRootAsConv3DOptions(ByteBuffer _bb) { return GetRootAsConv3DOptions(_bb, new Conv3DOptions()); }
  public static Conv3DOptions GetRootAsConv3DOptions(ByteBuffer _bb, Conv3DOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Conv3DOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.Padding Padding { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.Padding)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.Padding.SAME; } }
  public int StrideD { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int StrideW { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int StrideH { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType FusedActivationFunction { get { int o = __p.__offset(12); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE; } }
  public int DilationDFactor { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)1; } }
  public int DilationWFactor { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)1; } }
  public int DilationHFactor { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)1; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Conv3DOptions> CreateConv3DOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.Padding padding = Unity.InferenceEngine.Editor.LiteRT.Padding.SAME,
      int stride_d = 0,
      int stride_w = 0,
      int stride_h = 0,
      Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fused_activation_function = Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE,
      int dilation_d_factor = 1,
      int dilation_w_factor = 1,
      int dilation_h_factor = 1) {
    builder.StartTable(8);
    Conv3DOptions.AddDilationHFactor(builder, dilation_h_factor);
    Conv3DOptions.AddDilationWFactor(builder, dilation_w_factor);
    Conv3DOptions.AddDilationDFactor(builder, dilation_d_factor);
    Conv3DOptions.AddStrideH(builder, stride_h);
    Conv3DOptions.AddStrideW(builder, stride_w);
    Conv3DOptions.AddStrideD(builder, stride_d);
    Conv3DOptions.AddFusedActivationFunction(builder, fused_activation_function);
    Conv3DOptions.AddPadding(builder, padding);
    return Conv3DOptions.EndConv3DOptions(builder);
  }

  public static void StartConv3DOptions(FlatBufferBuilder builder) { builder.StartTable(8); }
  public static void AddPadding(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.Padding padding) { builder.AddSbyte(0, (sbyte)padding, 0); }
  public static void AddStrideD(FlatBufferBuilder builder, int strideD) { builder.AddInt(1, strideD, 0); }
  public static void AddStrideW(FlatBufferBuilder builder, int strideW) { builder.AddInt(2, strideW, 0); }
  public static void AddStrideH(FlatBufferBuilder builder, int strideH) { builder.AddInt(3, strideH, 0); }
  public static void AddFusedActivationFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fusedActivationFunction) { builder.AddSbyte(4, (sbyte)fusedActivationFunction, 0); }
  public static void AddDilationDFactor(FlatBufferBuilder builder, int dilationDFactor) { builder.AddInt(5, dilationDFactor, 1); }
  public static void AddDilationWFactor(FlatBufferBuilder builder, int dilationWFactor) { builder.AddInt(6, dilationWFactor, 1); }
  public static void AddDilationHFactor(FlatBufferBuilder builder, int dilationHFactor) { builder.AddInt(7, dilationHFactor, 1); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Conv3DOptions> EndConv3DOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.Conv3DOptions>(o);
  }
}


static class Conv3DOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Padding*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.Padding*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*StrideD*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*StrideW*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*StrideH*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 12 /*FusedActivationFunction*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType*/, 1, false)
      && verifier.VerifyField(tablePos, 14 /*DilationDFactor*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 16 /*DilationWFactor*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 18 /*DilationHFactor*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct Pool2DOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static Pool2DOptions GetRootAsPool2DOptions(ByteBuffer _bb) { return GetRootAsPool2DOptions(_bb, new Pool2DOptions()); }
  public static Pool2DOptions GetRootAsPool2DOptions(ByteBuffer _bb, Pool2DOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Pool2DOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.Padding Padding { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.Padding)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.Padding.SAME; } }
  public int StrideW { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int StrideH { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int FilterWidth { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int FilterHeight { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType FusedActivationFunction { get { int o = __p.__offset(14); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Pool2DOptions> CreatePool2DOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.Padding padding = Unity.InferenceEngine.Editor.LiteRT.Padding.SAME,
      int stride_w = 0,
      int stride_h = 0,
      int filter_width = 0,
      int filter_height = 0,
      Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fused_activation_function = Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE) {
    builder.StartTable(6);
    Pool2DOptions.AddFilterHeight(builder, filter_height);
    Pool2DOptions.AddFilterWidth(builder, filter_width);
    Pool2DOptions.AddStrideH(builder, stride_h);
    Pool2DOptions.AddStrideW(builder, stride_w);
    Pool2DOptions.AddFusedActivationFunction(builder, fused_activation_function);
    Pool2DOptions.AddPadding(builder, padding);
    return Pool2DOptions.EndPool2DOptions(builder);
  }

  public static void StartPool2DOptions(FlatBufferBuilder builder) { builder.StartTable(6); }
  public static void AddPadding(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.Padding padding) { builder.AddSbyte(0, (sbyte)padding, 0); }
  public static void AddStrideW(FlatBufferBuilder builder, int strideW) { builder.AddInt(1, strideW, 0); }
  public static void AddStrideH(FlatBufferBuilder builder, int strideH) { builder.AddInt(2, strideH, 0); }
  public static void AddFilterWidth(FlatBufferBuilder builder, int filterWidth) { builder.AddInt(3, filterWidth, 0); }
  public static void AddFilterHeight(FlatBufferBuilder builder, int filterHeight) { builder.AddInt(4, filterHeight, 0); }
  public static void AddFusedActivationFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fusedActivationFunction) { builder.AddSbyte(5, (sbyte)fusedActivationFunction, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Pool2DOptions> EndPool2DOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.Pool2DOptions>(o);
  }
}


static class Pool2DOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Padding*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.Padding*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*StrideW*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*StrideH*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*FilterWidth*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 12 /*FilterHeight*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 14 /*FusedActivationFunction*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct DepthwiseConv2DOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static DepthwiseConv2DOptions GetRootAsDepthwiseConv2DOptions(ByteBuffer _bb) { return GetRootAsDepthwiseConv2DOptions(_bb, new DepthwiseConv2DOptions()); }
  public static DepthwiseConv2DOptions GetRootAsDepthwiseConv2DOptions(ByteBuffer _bb, DepthwiseConv2DOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DepthwiseConv2DOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.Padding Padding { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.Padding)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.Padding.SAME; } }
  public int StrideW { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int StrideH { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int DepthMultiplier { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType FusedActivationFunction { get { int o = __p.__offset(12); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE; } }
  public int DilationWFactor { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)1; } }
  public int DilationHFactor { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)1; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.Padding padding = Unity.InferenceEngine.Editor.LiteRT.Padding.SAME,
      int stride_w = 0,
      int stride_h = 0,
      int depth_multiplier = 0,
      Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fused_activation_function = Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE,
      int dilation_w_factor = 1,
      int dilation_h_factor = 1) {
    builder.StartTable(7);
    DepthwiseConv2DOptions.AddDilationHFactor(builder, dilation_h_factor);
    DepthwiseConv2DOptions.AddDilationWFactor(builder, dilation_w_factor);
    DepthwiseConv2DOptions.AddDepthMultiplier(builder, depth_multiplier);
    DepthwiseConv2DOptions.AddStrideH(builder, stride_h);
    DepthwiseConv2DOptions.AddStrideW(builder, stride_w);
    DepthwiseConv2DOptions.AddFusedActivationFunction(builder, fused_activation_function);
    DepthwiseConv2DOptions.AddPadding(builder, padding);
    return DepthwiseConv2DOptions.EndDepthwiseConv2DOptions(builder);
  }

  public static void StartDepthwiseConv2DOptions(FlatBufferBuilder builder) { builder.StartTable(7); }
  public static void AddPadding(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.Padding padding) { builder.AddSbyte(0, (sbyte)padding, 0); }
  public static void AddStrideW(FlatBufferBuilder builder, int strideW) { builder.AddInt(1, strideW, 0); }
  public static void AddStrideH(FlatBufferBuilder builder, int strideH) { builder.AddInt(2, strideH, 0); }
  public static void AddDepthMultiplier(FlatBufferBuilder builder, int depthMultiplier) { builder.AddInt(3, depthMultiplier, 0); }
  public static void AddFusedActivationFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fusedActivationFunction) { builder.AddSbyte(4, (sbyte)fusedActivationFunction, 0); }
  public static void AddDilationWFactor(FlatBufferBuilder builder, int dilationWFactor) { builder.AddInt(5, dilationWFactor, 1); }
  public static void AddDilationHFactor(FlatBufferBuilder builder, int dilationHFactor) { builder.AddInt(6, dilationHFactor, 1); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.DepthwiseConv2DOptions> EndDepthwiseConv2DOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.DepthwiseConv2DOptions>(o);
  }
}


static class DepthwiseConv2DOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Padding*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.Padding*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*StrideW*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*StrideH*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*DepthMultiplier*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 12 /*FusedActivationFunction*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType*/, 1, false)
      && verifier.VerifyField(tablePos, 14 /*DilationWFactor*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 16 /*DilationHFactor*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct ConcatEmbeddingsOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ConcatEmbeddingsOptions GetRootAsConcatEmbeddingsOptions(ByteBuffer _bb) { return GetRootAsConcatEmbeddingsOptions(_bb, new ConcatEmbeddingsOptions()); }
  public static ConcatEmbeddingsOptions GetRootAsConcatEmbeddingsOptions(ByteBuffer _bb, ConcatEmbeddingsOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ConcatEmbeddingsOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int NumChannels { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int NumColumnsPerChannel(int j) { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int NumColumnsPerChannelLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetNumColumnsPerChannelBytes() { return __p.__vector_as_span<int>(6, 4); }
#else
  public ArraySegment<byte>? GetNumColumnsPerChannelBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public int[] GetNumColumnsPerChannelArray() { return __p.__vector_as_array<int>(6); }
  public int EmbeddingDimPerChannel(int j) { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int EmbeddingDimPerChannelLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetEmbeddingDimPerChannelBytes() { return __p.__vector_as_span<int>(8, 4); }
#else
  public ArraySegment<byte>? GetEmbeddingDimPerChannelBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public int[] GetEmbeddingDimPerChannelArray() { return __p.__vector_as_array<int>(8); }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(FlatBufferBuilder builder,
      int num_channels = 0,
      VectorOffset num_columns_per_channelOffset = default(VectorOffset),
      VectorOffset embedding_dim_per_channelOffset = default(VectorOffset)) {
    builder.StartTable(3);
    ConcatEmbeddingsOptions.AddEmbeddingDimPerChannel(builder, embedding_dim_per_channelOffset);
    ConcatEmbeddingsOptions.AddNumColumnsPerChannel(builder, num_columns_per_channelOffset);
    ConcatEmbeddingsOptions.AddNumChannels(builder, num_channels);
    return ConcatEmbeddingsOptions.EndConcatEmbeddingsOptions(builder);
  }

  public static void StartConcatEmbeddingsOptions(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddNumChannels(FlatBufferBuilder builder, int numChannels) { builder.AddInt(0, numChannels, 0); }
  public static void AddNumColumnsPerChannel(FlatBufferBuilder builder, VectorOffset numColumnsPerChannelOffset) { builder.AddOffset(1, numColumnsPerChannelOffset.Value, 0); }
  public static VectorOffset CreateNumColumnsPerChannelVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateNumColumnsPerChannelVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateNumColumnsPerChannelVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateNumColumnsPerChannelVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartNumColumnsPerChannelVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddEmbeddingDimPerChannel(FlatBufferBuilder builder, VectorOffset embeddingDimPerChannelOffset) { builder.AddOffset(2, embeddingDimPerChannelOffset.Value, 0); }
  public static VectorOffset CreateEmbeddingDimPerChannelVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateEmbeddingDimPerChannelVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateEmbeddingDimPerChannelVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateEmbeddingDimPerChannelVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartEmbeddingDimPerChannelVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ConcatEmbeddingsOptions> EndConcatEmbeddingsOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.ConcatEmbeddingsOptions>(o);
  }
}


static class ConcatEmbeddingsOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*NumChannels*/, 4 /*int*/, 4, false)
      && verifier.VerifyVectorOfData(tablePos, 6 /*NumColumnsPerChannel*/, 4 /*int*/, false)
      && verifier.VerifyVectorOfData(tablePos, 8 /*EmbeddingDimPerChannel*/, 4 /*int*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct LSHProjectionOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static LSHProjectionOptions GetRootAsLSHProjectionOptions(ByteBuffer _bb) { return GetRootAsLSHProjectionOptions(_bb, new LSHProjectionOptions()); }
  public static LSHProjectionOptions GetRootAsLSHProjectionOptions(ByteBuffer _bb, LSHProjectionOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public LSHProjectionOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.LSHProjectionType Type { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.LSHProjectionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.LSHProjectionType.UNKNOWN; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.LSHProjectionOptions> CreateLSHProjectionOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.LSHProjectionType type = Unity.InferenceEngine.Editor.LiteRT.LSHProjectionType.UNKNOWN) {
    builder.StartTable(1);
    LSHProjectionOptions.AddType(builder, type);
    return LSHProjectionOptions.EndLSHProjectionOptions(builder);
  }

  public static void StartLSHProjectionOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddType(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.LSHProjectionType type) { builder.AddSbyte(0, (sbyte)type, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.LSHProjectionOptions> EndLSHProjectionOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.LSHProjectionOptions>(o);
  }
}


static class LSHProjectionOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Type*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.LSHProjectionType*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SVDFOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SVDFOptions GetRootAsSVDFOptions(ByteBuffer _bb) { return GetRootAsSVDFOptions(_bb, new SVDFOptions()); }
  public static SVDFOptions GetRootAsSVDFOptions(ByteBuffer _bb, SVDFOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SVDFOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int Rank { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType FusedActivationFunction { get { int o = __p.__offset(6); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE; } }
  public bool AsymmetricQuantizeInputs { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SVDFOptions> CreateSVDFOptions(FlatBufferBuilder builder,
      int rank = 0,
      Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fused_activation_function = Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE,
      bool asymmetric_quantize_inputs = false) {
    builder.StartTable(3);
    SVDFOptions.AddRank(builder, rank);
    SVDFOptions.AddAsymmetricQuantizeInputs(builder, asymmetric_quantize_inputs);
    SVDFOptions.AddFusedActivationFunction(builder, fused_activation_function);
    return SVDFOptions.EndSVDFOptions(builder);
  }

  public static void StartSVDFOptions(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddRank(FlatBufferBuilder builder, int rank) { builder.AddInt(0, rank, 0); }
  public static void AddFusedActivationFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fusedActivationFunction) { builder.AddSbyte(1, (sbyte)fusedActivationFunction, 0); }
  public static void AddAsymmetricQuantizeInputs(FlatBufferBuilder builder, bool asymmetricQuantizeInputs) { builder.AddBool(2, asymmetricQuantizeInputs, false); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SVDFOptions> EndSVDFOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SVDFOptions>(o);
  }
}


static class SVDFOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Rank*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*FusedActivationFunction*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType*/, 1, false)
      && verifier.VerifyField(tablePos, 8 /*AsymmetricQuantizeInputs*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct RNNOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static RNNOptions GetRootAsRNNOptions(ByteBuffer _bb) { return GetRootAsRNNOptions(_bb, new RNNOptions()); }
  public static RNNOptions GetRootAsRNNOptions(ByteBuffer _bb, RNNOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RNNOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType FusedActivationFunction { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE; } }
  public bool AsymmetricQuantizeInputs { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.RNNOptions> CreateRNNOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fused_activation_function = Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE,
      bool asymmetric_quantize_inputs = false) {
    builder.StartTable(2);
    RNNOptions.AddAsymmetricQuantizeInputs(builder, asymmetric_quantize_inputs);
    RNNOptions.AddFusedActivationFunction(builder, fused_activation_function);
    return RNNOptions.EndRNNOptions(builder);
  }

  public static void StartRNNOptions(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddFusedActivationFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fusedActivationFunction) { builder.AddSbyte(0, (sbyte)fusedActivationFunction, 0); }
  public static void AddAsymmetricQuantizeInputs(FlatBufferBuilder builder, bool asymmetricQuantizeInputs) { builder.AddBool(1, asymmetricQuantizeInputs, false); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.RNNOptions> EndRNNOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.RNNOptions>(o);
  }
}


static class RNNOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*FusedActivationFunction*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*AsymmetricQuantizeInputs*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SequenceRNNOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SequenceRNNOptions GetRootAsSequenceRNNOptions(ByteBuffer _bb) { return GetRootAsSequenceRNNOptions(_bb, new SequenceRNNOptions()); }
  public static SequenceRNNOptions GetRootAsSequenceRNNOptions(ByteBuffer _bb, SequenceRNNOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SequenceRNNOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool TimeMajor { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType FusedActivationFunction { get { int o = __p.__offset(6); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE; } }
  public bool AsymmetricQuantizeInputs { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SequenceRNNOptions> CreateSequenceRNNOptions(FlatBufferBuilder builder,
      bool time_major = false,
      Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fused_activation_function = Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE,
      bool asymmetric_quantize_inputs = false) {
    builder.StartTable(3);
    SequenceRNNOptions.AddAsymmetricQuantizeInputs(builder, asymmetric_quantize_inputs);
    SequenceRNNOptions.AddFusedActivationFunction(builder, fused_activation_function);
    SequenceRNNOptions.AddTimeMajor(builder, time_major);
    return SequenceRNNOptions.EndSequenceRNNOptions(builder);
  }

  public static void StartSequenceRNNOptions(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddTimeMajor(FlatBufferBuilder builder, bool timeMajor) { builder.AddBool(0, timeMajor, false); }
  public static void AddFusedActivationFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fusedActivationFunction) { builder.AddSbyte(1, (sbyte)fusedActivationFunction, 0); }
  public static void AddAsymmetricQuantizeInputs(FlatBufferBuilder builder, bool asymmetricQuantizeInputs) { builder.AddBool(2, asymmetricQuantizeInputs, false); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SequenceRNNOptions> EndSequenceRNNOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SequenceRNNOptions>(o);
  }
}


static class SequenceRNNOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*TimeMajor*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*FusedActivationFunction*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType*/, 1, false)
      && verifier.VerifyField(tablePos, 8 /*AsymmetricQuantizeInputs*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct BidirectionalSequenceRNNOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static BidirectionalSequenceRNNOptions GetRootAsBidirectionalSequenceRNNOptions(ByteBuffer _bb) { return GetRootAsBidirectionalSequenceRNNOptions(_bb, new BidirectionalSequenceRNNOptions()); }
  public static BidirectionalSequenceRNNOptions GetRootAsBidirectionalSequenceRNNOptions(ByteBuffer _bb, BidirectionalSequenceRNNOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BidirectionalSequenceRNNOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool TimeMajor { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType FusedActivationFunction { get { int o = __p.__offset(6); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE; } }
  public bool MergeOutputs { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool AsymmetricQuantizeInputs { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(FlatBufferBuilder builder,
      bool time_major = false,
      Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fused_activation_function = Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE,
      bool merge_outputs = false,
      bool asymmetric_quantize_inputs = false) {
    builder.StartTable(4);
    BidirectionalSequenceRNNOptions.AddAsymmetricQuantizeInputs(builder, asymmetric_quantize_inputs);
    BidirectionalSequenceRNNOptions.AddMergeOutputs(builder, merge_outputs);
    BidirectionalSequenceRNNOptions.AddFusedActivationFunction(builder, fused_activation_function);
    BidirectionalSequenceRNNOptions.AddTimeMajor(builder, time_major);
    return BidirectionalSequenceRNNOptions.EndBidirectionalSequenceRNNOptions(builder);
  }

  public static void StartBidirectionalSequenceRNNOptions(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddTimeMajor(FlatBufferBuilder builder, bool timeMajor) { builder.AddBool(0, timeMajor, false); }
  public static void AddFusedActivationFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fusedActivationFunction) { builder.AddSbyte(1, (sbyte)fusedActivationFunction, 0); }
  public static void AddMergeOutputs(FlatBufferBuilder builder, bool mergeOutputs) { builder.AddBool(2, mergeOutputs, false); }
  public static void AddAsymmetricQuantizeInputs(FlatBufferBuilder builder, bool asymmetricQuantizeInputs) { builder.AddBool(3, asymmetricQuantizeInputs, false); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.BidirectionalSequenceRNNOptions> EndBidirectionalSequenceRNNOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.BidirectionalSequenceRNNOptions>(o);
  }
}


static class BidirectionalSequenceRNNOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*TimeMajor*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*FusedActivationFunction*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType*/, 1, false)
      && verifier.VerifyField(tablePos, 8 /*MergeOutputs*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*AsymmetricQuantizeInputs*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct FullyConnectedOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static FullyConnectedOptions GetRootAsFullyConnectedOptions(ByteBuffer _bb) { return GetRootAsFullyConnectedOptions(_bb, new FullyConnectedOptions()); }
  public static FullyConnectedOptions GetRootAsFullyConnectedOptions(ByteBuffer _bb, FullyConnectedOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public FullyConnectedOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType FusedActivationFunction { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE; } }
  public Unity.InferenceEngine.Editor.LiteRT.FullyConnectedOptionsWeightsFormat WeightsFormat { get { int o = __p.__offset(6); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.FullyConnectedOptionsWeightsFormat)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.FullyConnectedOptionsWeightsFormat.DEFAULT; } }
  public bool KeepNumDims { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool AsymmetricQuantizeInputs { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public Unity.InferenceEngine.Editor.LiteRT.TensorType QuantizedBiasType { get { int o = __p.__offset(12); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.TensorType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.FullyConnectedOptions> CreateFullyConnectedOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fused_activation_function = Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE,
      Unity.InferenceEngine.Editor.LiteRT.FullyConnectedOptionsWeightsFormat weights_format = Unity.InferenceEngine.Editor.LiteRT.FullyConnectedOptionsWeightsFormat.DEFAULT,
      bool keep_num_dims = false,
      bool asymmetric_quantize_inputs = false,
      Unity.InferenceEngine.Editor.LiteRT.TensorType quantized_bias_type = Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32) {
    builder.StartTable(5);
    FullyConnectedOptions.AddQuantizedBiasType(builder, quantized_bias_type);
    FullyConnectedOptions.AddAsymmetricQuantizeInputs(builder, asymmetric_quantize_inputs);
    FullyConnectedOptions.AddKeepNumDims(builder, keep_num_dims);
    FullyConnectedOptions.AddWeightsFormat(builder, weights_format);
    FullyConnectedOptions.AddFusedActivationFunction(builder, fused_activation_function);
    return FullyConnectedOptions.EndFullyConnectedOptions(builder);
  }

  public static void StartFullyConnectedOptions(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddFusedActivationFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fusedActivationFunction) { builder.AddSbyte(0, (sbyte)fusedActivationFunction, 0); }
  public static void AddWeightsFormat(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.FullyConnectedOptionsWeightsFormat weightsFormat) { builder.AddSbyte(1, (sbyte)weightsFormat, 0); }
  public static void AddKeepNumDims(FlatBufferBuilder builder, bool keepNumDims) { builder.AddBool(2, keepNumDims, false); }
  public static void AddAsymmetricQuantizeInputs(FlatBufferBuilder builder, bool asymmetricQuantizeInputs) { builder.AddBool(3, asymmetricQuantizeInputs, false); }
  public static void AddQuantizedBiasType(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.TensorType quantizedBiasType) { builder.AddSbyte(4, (sbyte)quantizedBiasType, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.FullyConnectedOptions> EndFullyConnectedOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.FullyConnectedOptions>(o);
  }
}


static class FullyConnectedOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*FusedActivationFunction*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*WeightsFormat*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.FullyConnectedOptionsWeightsFormat*/, 1, false)
      && verifier.VerifyField(tablePos, 8 /*KeepNumDims*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*AsymmetricQuantizeInputs*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 12 /*QuantizedBiasType*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.TensorType*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SoftmaxOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SoftmaxOptions GetRootAsSoftmaxOptions(ByteBuffer _bb) { return GetRootAsSoftmaxOptions(_bb, new SoftmaxOptions()); }
  public static SoftmaxOptions GetRootAsSoftmaxOptions(ByteBuffer _bb, SoftmaxOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SoftmaxOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float Beta { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SoftmaxOptions> CreateSoftmaxOptions(FlatBufferBuilder builder,
      float beta = 0.0f) {
    builder.StartTable(1);
    SoftmaxOptions.AddBeta(builder, beta);
    return SoftmaxOptions.EndSoftmaxOptions(builder);
  }

  public static void StartSoftmaxOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddBeta(FlatBufferBuilder builder, float beta) { builder.AddFloat(0, beta, 0.0f); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SoftmaxOptions> EndSoftmaxOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SoftmaxOptions>(o);
  }
}


static class SoftmaxOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Beta*/, 4 /*float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct ConcatenationOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ConcatenationOptions GetRootAsConcatenationOptions(ByteBuffer _bb) { return GetRootAsConcatenationOptions(_bb, new ConcatenationOptions()); }
  public static ConcatenationOptions GetRootAsConcatenationOptions(ByteBuffer _bb, ConcatenationOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ConcatenationOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int Axis { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType FusedActivationFunction { get { int o = __p.__offset(6); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ConcatenationOptions> CreateConcatenationOptions(FlatBufferBuilder builder,
      int axis = 0,
      Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fused_activation_function = Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE) {
    builder.StartTable(2);
    ConcatenationOptions.AddAxis(builder, axis);
    ConcatenationOptions.AddFusedActivationFunction(builder, fused_activation_function);
    return ConcatenationOptions.EndConcatenationOptions(builder);
  }

  public static void StartConcatenationOptions(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddAxis(FlatBufferBuilder builder, int axis) { builder.AddInt(0, axis, 0); }
  public static void AddFusedActivationFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fusedActivationFunction) { builder.AddSbyte(1, (sbyte)fusedActivationFunction, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ConcatenationOptions> EndConcatenationOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.ConcatenationOptions>(o);
  }
}


static class ConcatenationOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Axis*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*FusedActivationFunction*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct AddOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static AddOptions GetRootAsAddOptions(ByteBuffer _bb) { return GetRootAsAddOptions(_bb, new AddOptions()); }
  public static AddOptions GetRootAsAddOptions(ByteBuffer _bb, AddOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public AddOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType FusedActivationFunction { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE; } }
  public bool PotScaleInt16 { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)true; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.AddOptions> CreateAddOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fused_activation_function = Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE,
      bool pot_scale_int16 = true) {
    builder.StartTable(2);
    AddOptions.AddPotScaleInt16(builder, pot_scale_int16);
    AddOptions.AddFusedActivationFunction(builder, fused_activation_function);
    return AddOptions.EndAddOptions(builder);
  }

  public static void StartAddOptions(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddFusedActivationFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fusedActivationFunction) { builder.AddSbyte(0, (sbyte)fusedActivationFunction, 0); }
  public static void AddPotScaleInt16(FlatBufferBuilder builder, bool potScaleInt16) { builder.AddBool(1, potScaleInt16, true); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.AddOptions> EndAddOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.AddOptions>(o);
  }
}


static class AddOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*FusedActivationFunction*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*PotScaleInt16*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct MulOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static MulOptions GetRootAsMulOptions(ByteBuffer _bb) { return GetRootAsMulOptions(_bb, new MulOptions()); }
  public static MulOptions GetRootAsMulOptions(ByteBuffer _bb, MulOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public MulOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType FusedActivationFunction { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.MulOptions> CreateMulOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fused_activation_function = Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE) {
    builder.StartTable(1);
    MulOptions.AddFusedActivationFunction(builder, fused_activation_function);
    return MulOptions.EndMulOptions(builder);
  }

  public static void StartMulOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddFusedActivationFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fusedActivationFunction) { builder.AddSbyte(0, (sbyte)fusedActivationFunction, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.MulOptions> EndMulOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.MulOptions>(o);
  }
}


static class MulOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*FusedActivationFunction*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct L2NormOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static L2NormOptions GetRootAsL2NormOptions(ByteBuffer _bb) { return GetRootAsL2NormOptions(_bb, new L2NormOptions()); }
  public static L2NormOptions GetRootAsL2NormOptions(ByteBuffer _bb, L2NormOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public L2NormOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType FusedActivationFunction { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.L2NormOptions> CreateL2NormOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fused_activation_function = Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE) {
    builder.StartTable(1);
    L2NormOptions.AddFusedActivationFunction(builder, fused_activation_function);
    return L2NormOptions.EndL2NormOptions(builder);
  }

  public static void StartL2NormOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddFusedActivationFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fusedActivationFunction) { builder.AddSbyte(0, (sbyte)fusedActivationFunction, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.L2NormOptions> EndL2NormOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.L2NormOptions>(o);
  }
}


static class L2NormOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*FusedActivationFunction*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct LocalResponseNormalizationOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static LocalResponseNormalizationOptions GetRootAsLocalResponseNormalizationOptions(ByteBuffer _bb) { return GetRootAsLocalResponseNormalizationOptions(_bb, new LocalResponseNormalizationOptions()); }
  public static LocalResponseNormalizationOptions GetRootAsLocalResponseNormalizationOptions(ByteBuffer _bb, LocalResponseNormalizationOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public LocalResponseNormalizationOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int Radius { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public float Bias { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float Alpha { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float Beta { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(FlatBufferBuilder builder,
      int radius = 0,
      float bias = 0.0f,
      float alpha = 0.0f,
      float beta = 0.0f) {
    builder.StartTable(4);
    LocalResponseNormalizationOptions.AddBeta(builder, beta);
    LocalResponseNormalizationOptions.AddAlpha(builder, alpha);
    LocalResponseNormalizationOptions.AddBias(builder, bias);
    LocalResponseNormalizationOptions.AddRadius(builder, radius);
    return LocalResponseNormalizationOptions.EndLocalResponseNormalizationOptions(builder);
  }

  public static void StartLocalResponseNormalizationOptions(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddRadius(FlatBufferBuilder builder, int radius) { builder.AddInt(0, radius, 0); }
  public static void AddBias(FlatBufferBuilder builder, float bias) { builder.AddFloat(1, bias, 0.0f); }
  public static void AddAlpha(FlatBufferBuilder builder, float alpha) { builder.AddFloat(2, alpha, 0.0f); }
  public static void AddBeta(FlatBufferBuilder builder, float beta) { builder.AddFloat(3, beta, 0.0f); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.LocalResponseNormalizationOptions> EndLocalResponseNormalizationOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.LocalResponseNormalizationOptions>(o);
  }
}


static class LocalResponseNormalizationOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Radius*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Bias*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Alpha*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*Beta*/, 4 /*float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct LSTMOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static LSTMOptions GetRootAsLSTMOptions(ByteBuffer _bb) { return GetRootAsLSTMOptions(_bb, new LSTMOptions()); }
  public static LSTMOptions GetRootAsLSTMOptions(ByteBuffer _bb, LSTMOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public LSTMOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType FusedActivationFunction { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE; } }
  public float CellClip { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float ProjClip { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public Unity.InferenceEngine.Editor.LiteRT.LSTMKernelType KernelType { get { int o = __p.__offset(10); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.LSTMKernelType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.LSTMKernelType.FULL; } }
  public bool AsymmetricQuantizeInputs { get { int o = __p.__offset(12); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.LSTMOptions> CreateLSTMOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fused_activation_function = Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE,
      float cell_clip = 0.0f,
      float proj_clip = 0.0f,
      Unity.InferenceEngine.Editor.LiteRT.LSTMKernelType kernel_type = Unity.InferenceEngine.Editor.LiteRT.LSTMKernelType.FULL,
      bool asymmetric_quantize_inputs = false) {
    builder.StartTable(5);
    LSTMOptions.AddProjClip(builder, proj_clip);
    LSTMOptions.AddCellClip(builder, cell_clip);
    LSTMOptions.AddAsymmetricQuantizeInputs(builder, asymmetric_quantize_inputs);
    LSTMOptions.AddKernelType(builder, kernel_type);
    LSTMOptions.AddFusedActivationFunction(builder, fused_activation_function);
    return LSTMOptions.EndLSTMOptions(builder);
  }

  public static void StartLSTMOptions(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddFusedActivationFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fusedActivationFunction) { builder.AddSbyte(0, (sbyte)fusedActivationFunction, 0); }
  public static void AddCellClip(FlatBufferBuilder builder, float cellClip) { builder.AddFloat(1, cellClip, 0.0f); }
  public static void AddProjClip(FlatBufferBuilder builder, float projClip) { builder.AddFloat(2, projClip, 0.0f); }
  public static void AddKernelType(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.LSTMKernelType kernelType) { builder.AddSbyte(3, (sbyte)kernelType, 0); }
  public static void AddAsymmetricQuantizeInputs(FlatBufferBuilder builder, bool asymmetricQuantizeInputs) { builder.AddBool(4, asymmetricQuantizeInputs, false); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.LSTMOptions> EndLSTMOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.LSTMOptions>(o);
  }
}


static class LSTMOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*FusedActivationFunction*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*CellClip*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*ProjClip*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*KernelType*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.LSTMKernelType*/, 1, false)
      && verifier.VerifyField(tablePos, 12 /*AsymmetricQuantizeInputs*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct UnidirectionalSequenceLSTMOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static UnidirectionalSequenceLSTMOptions GetRootAsUnidirectionalSequenceLSTMOptions(ByteBuffer _bb) { return GetRootAsUnidirectionalSequenceLSTMOptions(_bb, new UnidirectionalSequenceLSTMOptions()); }
  public static UnidirectionalSequenceLSTMOptions GetRootAsUnidirectionalSequenceLSTMOptions(ByteBuffer _bb, UnidirectionalSequenceLSTMOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public UnidirectionalSequenceLSTMOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType FusedActivationFunction { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE; } }
  public float CellClip { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float ProjClip { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public bool TimeMajor { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool AsymmetricQuantizeInputs { get { int o = __p.__offset(12); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool DiagonalRecurrentTensors { get { int o = __p.__offset(14); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fused_activation_function = Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE,
      float cell_clip = 0.0f,
      float proj_clip = 0.0f,
      bool time_major = false,
      bool asymmetric_quantize_inputs = false,
      bool diagonal_recurrent_tensors = false) {
    builder.StartTable(6);
    UnidirectionalSequenceLSTMOptions.AddProjClip(builder, proj_clip);
    UnidirectionalSequenceLSTMOptions.AddCellClip(builder, cell_clip);
    UnidirectionalSequenceLSTMOptions.AddDiagonalRecurrentTensors(builder, diagonal_recurrent_tensors);
    UnidirectionalSequenceLSTMOptions.AddAsymmetricQuantizeInputs(builder, asymmetric_quantize_inputs);
    UnidirectionalSequenceLSTMOptions.AddTimeMajor(builder, time_major);
    UnidirectionalSequenceLSTMOptions.AddFusedActivationFunction(builder, fused_activation_function);
    return UnidirectionalSequenceLSTMOptions.EndUnidirectionalSequenceLSTMOptions(builder);
  }

  public static void StartUnidirectionalSequenceLSTMOptions(FlatBufferBuilder builder) { builder.StartTable(6); }
  public static void AddFusedActivationFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fusedActivationFunction) { builder.AddSbyte(0, (sbyte)fusedActivationFunction, 0); }
  public static void AddCellClip(FlatBufferBuilder builder, float cellClip) { builder.AddFloat(1, cellClip, 0.0f); }
  public static void AddProjClip(FlatBufferBuilder builder, float projClip) { builder.AddFloat(2, projClip, 0.0f); }
  public static void AddTimeMajor(FlatBufferBuilder builder, bool timeMajor) { builder.AddBool(3, timeMajor, false); }
  public static void AddAsymmetricQuantizeInputs(FlatBufferBuilder builder, bool asymmetricQuantizeInputs) { builder.AddBool(4, asymmetricQuantizeInputs, false); }
  public static void AddDiagonalRecurrentTensors(FlatBufferBuilder builder, bool diagonalRecurrentTensors) { builder.AddBool(5, diagonalRecurrentTensors, false); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.UnidirectionalSequenceLSTMOptions> EndUnidirectionalSequenceLSTMOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.UnidirectionalSequenceLSTMOptions>(o);
  }
}


static class UnidirectionalSequenceLSTMOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*FusedActivationFunction*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*CellClip*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*ProjClip*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*TimeMajor*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 12 /*AsymmetricQuantizeInputs*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 14 /*DiagonalRecurrentTensors*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct BidirectionalSequenceLSTMOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static BidirectionalSequenceLSTMOptions GetRootAsBidirectionalSequenceLSTMOptions(ByteBuffer _bb) { return GetRootAsBidirectionalSequenceLSTMOptions(_bb, new BidirectionalSequenceLSTMOptions()); }
  public static BidirectionalSequenceLSTMOptions GetRootAsBidirectionalSequenceLSTMOptions(ByteBuffer _bb, BidirectionalSequenceLSTMOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BidirectionalSequenceLSTMOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType FusedActivationFunction { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE; } }
  public float CellClip { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float ProjClip { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public bool MergeOutputs { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool TimeMajor { get { int o = __p.__offset(12); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)true; } }
  public bool AsymmetricQuantizeInputs { get { int o = __p.__offset(14); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fused_activation_function = Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE,
      float cell_clip = 0.0f,
      float proj_clip = 0.0f,
      bool merge_outputs = false,
      bool time_major = true,
      bool asymmetric_quantize_inputs = false) {
    builder.StartTable(6);
    BidirectionalSequenceLSTMOptions.AddProjClip(builder, proj_clip);
    BidirectionalSequenceLSTMOptions.AddCellClip(builder, cell_clip);
    BidirectionalSequenceLSTMOptions.AddAsymmetricQuantizeInputs(builder, asymmetric_quantize_inputs);
    BidirectionalSequenceLSTMOptions.AddTimeMajor(builder, time_major);
    BidirectionalSequenceLSTMOptions.AddMergeOutputs(builder, merge_outputs);
    BidirectionalSequenceLSTMOptions.AddFusedActivationFunction(builder, fused_activation_function);
    return BidirectionalSequenceLSTMOptions.EndBidirectionalSequenceLSTMOptions(builder);
  }

  public static void StartBidirectionalSequenceLSTMOptions(FlatBufferBuilder builder) { builder.StartTable(6); }
  public static void AddFusedActivationFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fusedActivationFunction) { builder.AddSbyte(0, (sbyte)fusedActivationFunction, 0); }
  public static void AddCellClip(FlatBufferBuilder builder, float cellClip) { builder.AddFloat(1, cellClip, 0.0f); }
  public static void AddProjClip(FlatBufferBuilder builder, float projClip) { builder.AddFloat(2, projClip, 0.0f); }
  public static void AddMergeOutputs(FlatBufferBuilder builder, bool mergeOutputs) { builder.AddBool(3, mergeOutputs, false); }
  public static void AddTimeMajor(FlatBufferBuilder builder, bool timeMajor) { builder.AddBool(4, timeMajor, true); }
  public static void AddAsymmetricQuantizeInputs(FlatBufferBuilder builder, bool asymmetricQuantizeInputs) { builder.AddBool(5, asymmetricQuantizeInputs, false); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.BidirectionalSequenceLSTMOptions> EndBidirectionalSequenceLSTMOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.BidirectionalSequenceLSTMOptions>(o);
  }
}


static class BidirectionalSequenceLSTMOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*FusedActivationFunction*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*CellClip*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*ProjClip*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*MergeOutputs*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 12 /*TimeMajor*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 14 /*AsymmetricQuantizeInputs*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct ResizeBilinearOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ResizeBilinearOptions GetRootAsResizeBilinearOptions(ByteBuffer _bb) { return GetRootAsResizeBilinearOptions(_bb, new ResizeBilinearOptions()); }
  public static ResizeBilinearOptions GetRootAsResizeBilinearOptions(ByteBuffer _bb, ResizeBilinearOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ResizeBilinearOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool AlignCorners { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool HalfPixelCenters { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ResizeBilinearOptions> CreateResizeBilinearOptions(FlatBufferBuilder builder,
      bool align_corners = false,
      bool half_pixel_centers = false) {
    builder.StartTable(4);
    ResizeBilinearOptions.AddHalfPixelCenters(builder, half_pixel_centers);
    ResizeBilinearOptions.AddAlignCorners(builder, align_corners);
    return ResizeBilinearOptions.EndResizeBilinearOptions(builder);
  }

  public static void StartResizeBilinearOptions(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddAlignCorners(FlatBufferBuilder builder, bool alignCorners) { builder.AddBool(2, alignCorners, false); }
  public static void AddHalfPixelCenters(FlatBufferBuilder builder, bool halfPixelCenters) { builder.AddBool(3, halfPixelCenters, false); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ResizeBilinearOptions> EndResizeBilinearOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.ResizeBilinearOptions>(o);
  }
}


static class ResizeBilinearOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 8 /*AlignCorners*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*HalfPixelCenters*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct ResizeNearestNeighborOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ResizeNearestNeighborOptions GetRootAsResizeNearestNeighborOptions(ByteBuffer _bb) { return GetRootAsResizeNearestNeighborOptions(_bb, new ResizeNearestNeighborOptions()); }
  public static ResizeNearestNeighborOptions GetRootAsResizeNearestNeighborOptions(ByteBuffer _bb, ResizeNearestNeighborOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ResizeNearestNeighborOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool AlignCorners { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool HalfPixelCenters { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(FlatBufferBuilder builder,
      bool align_corners = false,
      bool half_pixel_centers = false) {
    builder.StartTable(2);
    ResizeNearestNeighborOptions.AddHalfPixelCenters(builder, half_pixel_centers);
    ResizeNearestNeighborOptions.AddAlignCorners(builder, align_corners);
    return ResizeNearestNeighborOptions.EndResizeNearestNeighborOptions(builder);
  }

  public static void StartResizeNearestNeighborOptions(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddAlignCorners(FlatBufferBuilder builder, bool alignCorners) { builder.AddBool(0, alignCorners, false); }
  public static void AddHalfPixelCenters(FlatBufferBuilder builder, bool halfPixelCenters) { builder.AddBool(1, halfPixelCenters, false); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ResizeNearestNeighborOptions> EndResizeNearestNeighborOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.ResizeNearestNeighborOptions>(o);
  }
}


static class ResizeNearestNeighborOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*AlignCorners*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*HalfPixelCenters*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct CallOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static CallOptions GetRootAsCallOptions(ByteBuffer _bb) { return GetRootAsCallOptions(_bb, new CallOptions()); }
  public static CallOptions GetRootAsCallOptions(ByteBuffer _bb, CallOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public CallOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public uint Subgraph { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.CallOptions> CreateCallOptions(FlatBufferBuilder builder,
      uint subgraph = 0) {
    builder.StartTable(1);
    CallOptions.AddSubgraph(builder, subgraph);
    return CallOptions.EndCallOptions(builder);
  }

  public static void StartCallOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddSubgraph(FlatBufferBuilder builder, uint subgraph) { builder.AddUint(0, subgraph, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.CallOptions> EndCallOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.CallOptions>(o);
  }
}


static class CallOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Subgraph*/, 4 /*uint*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct PadOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static PadOptions GetRootAsPadOptions(ByteBuffer _bb) { return GetRootAsPadOptions(_bb, new PadOptions()); }
  public static PadOptions GetRootAsPadOptions(ByteBuffer _bb, PadOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PadOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartPadOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.PadOptions> EndPadOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.PadOptions>(o);
  }
}


static class PadOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct PadV2Options : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static PadV2Options GetRootAsPadV2Options(ByteBuffer _bb) { return GetRootAsPadV2Options(_bb, new PadV2Options()); }
  public static PadV2Options GetRootAsPadV2Options(ByteBuffer _bb, PadV2Options obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PadV2Options __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartPadV2Options(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.PadV2Options> EndPadV2Options(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.PadV2Options>(o);
  }
}


static class PadV2OptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct ReshapeOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ReshapeOptions GetRootAsReshapeOptions(ByteBuffer _bb) { return GetRootAsReshapeOptions(_bb, new ReshapeOptions()); }
  public static ReshapeOptions GetRootAsReshapeOptions(ByteBuffer _bb, ReshapeOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ReshapeOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int NewShape(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int NewShapeLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetNewShapeBytes() { return __p.__vector_as_span<int>(4, 4); }
#else
  public ArraySegment<byte>? GetNewShapeBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public int[] GetNewShapeArray() { return __p.__vector_as_array<int>(4); }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ReshapeOptions> CreateReshapeOptions(FlatBufferBuilder builder,
      VectorOffset new_shapeOffset = default(VectorOffset)) {
    builder.StartTable(1);
    ReshapeOptions.AddNewShape(builder, new_shapeOffset);
    return ReshapeOptions.EndReshapeOptions(builder);
  }

  public static void StartReshapeOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddNewShape(FlatBufferBuilder builder, VectorOffset newShapeOffset) { builder.AddOffset(0, newShapeOffset.Value, 0); }
  public static VectorOffset CreateNewShapeVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateNewShapeVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateNewShapeVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateNewShapeVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartNewShapeVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ReshapeOptions> EndReshapeOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.ReshapeOptions>(o);
  }
}


static class ReshapeOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*NewShape*/, 4 /*int*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SpaceToBatchNDOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SpaceToBatchNDOptions GetRootAsSpaceToBatchNDOptions(ByteBuffer _bb) { return GetRootAsSpaceToBatchNDOptions(_bb, new SpaceToBatchNDOptions()); }
  public static SpaceToBatchNDOptions GetRootAsSpaceToBatchNDOptions(ByteBuffer _bb, SpaceToBatchNDOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SpaceToBatchNDOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartSpaceToBatchNDOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SpaceToBatchNDOptions> EndSpaceToBatchNDOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SpaceToBatchNDOptions>(o);
  }
}


static class SpaceToBatchNDOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct BatchToSpaceNDOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static BatchToSpaceNDOptions GetRootAsBatchToSpaceNDOptions(ByteBuffer _bb) { return GetRootAsBatchToSpaceNDOptions(_bb, new BatchToSpaceNDOptions()); }
  public static BatchToSpaceNDOptions GetRootAsBatchToSpaceNDOptions(ByteBuffer _bb, BatchToSpaceNDOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BatchToSpaceNDOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartBatchToSpaceNDOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.BatchToSpaceNDOptions> EndBatchToSpaceNDOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.BatchToSpaceNDOptions>(o);
  }
}


static class BatchToSpaceNDOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SkipGramOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SkipGramOptions GetRootAsSkipGramOptions(ByteBuffer _bb) { return GetRootAsSkipGramOptions(_bb, new SkipGramOptions()); }
  public static SkipGramOptions GetRootAsSkipGramOptions(ByteBuffer _bb, SkipGramOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SkipGramOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int NgramSize { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int MaxSkipSize { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public bool IncludeAllNgrams { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SkipGramOptions> CreateSkipGramOptions(FlatBufferBuilder builder,
      int ngram_size = 0,
      int max_skip_size = 0,
      bool include_all_ngrams = false) {
    builder.StartTable(3);
    SkipGramOptions.AddMaxSkipSize(builder, max_skip_size);
    SkipGramOptions.AddNgramSize(builder, ngram_size);
    SkipGramOptions.AddIncludeAllNgrams(builder, include_all_ngrams);
    return SkipGramOptions.EndSkipGramOptions(builder);
  }

  public static void StartSkipGramOptions(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddNgramSize(FlatBufferBuilder builder, int ngramSize) { builder.AddInt(0, ngramSize, 0); }
  public static void AddMaxSkipSize(FlatBufferBuilder builder, int maxSkipSize) { builder.AddInt(1, maxSkipSize, 0); }
  public static void AddIncludeAllNgrams(FlatBufferBuilder builder, bool includeAllNgrams) { builder.AddBool(2, includeAllNgrams, false); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SkipGramOptions> EndSkipGramOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SkipGramOptions>(o);
  }
}


static class SkipGramOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*NgramSize*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*MaxSkipSize*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*IncludeAllNgrams*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SpaceToDepthOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SpaceToDepthOptions GetRootAsSpaceToDepthOptions(ByteBuffer _bb) { return GetRootAsSpaceToDepthOptions(_bb, new SpaceToDepthOptions()); }
  public static SpaceToDepthOptions GetRootAsSpaceToDepthOptions(ByteBuffer _bb, SpaceToDepthOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SpaceToDepthOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int BlockSize { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SpaceToDepthOptions> CreateSpaceToDepthOptions(FlatBufferBuilder builder,
      int block_size = 0) {
    builder.StartTable(1);
    SpaceToDepthOptions.AddBlockSize(builder, block_size);
    return SpaceToDepthOptions.EndSpaceToDepthOptions(builder);
  }

  public static void StartSpaceToDepthOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddBlockSize(FlatBufferBuilder builder, int blockSize) { builder.AddInt(0, blockSize, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SpaceToDepthOptions> EndSpaceToDepthOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SpaceToDepthOptions>(o);
  }
}


static class SpaceToDepthOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*BlockSize*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct DepthToSpaceOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static DepthToSpaceOptions GetRootAsDepthToSpaceOptions(ByteBuffer _bb) { return GetRootAsDepthToSpaceOptions(_bb, new DepthToSpaceOptions()); }
  public static DepthToSpaceOptions GetRootAsDepthToSpaceOptions(ByteBuffer _bb, DepthToSpaceOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DepthToSpaceOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int BlockSize { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.DepthToSpaceOptions> CreateDepthToSpaceOptions(FlatBufferBuilder builder,
      int block_size = 0) {
    builder.StartTable(1);
    DepthToSpaceOptions.AddBlockSize(builder, block_size);
    return DepthToSpaceOptions.EndDepthToSpaceOptions(builder);
  }

  public static void StartDepthToSpaceOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddBlockSize(FlatBufferBuilder builder, int blockSize) { builder.AddInt(0, blockSize, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.DepthToSpaceOptions> EndDepthToSpaceOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.DepthToSpaceOptions>(o);
  }
}


static class DepthToSpaceOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*BlockSize*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SubOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SubOptions GetRootAsSubOptions(ByteBuffer _bb) { return GetRootAsSubOptions(_bb, new SubOptions()); }
  public static SubOptions GetRootAsSubOptions(ByteBuffer _bb, SubOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SubOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType FusedActivationFunction { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE; } }
  public bool PotScaleInt16 { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)true; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SubOptions> CreateSubOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fused_activation_function = Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE,
      bool pot_scale_int16 = true) {
    builder.StartTable(2);
    SubOptions.AddPotScaleInt16(builder, pot_scale_int16);
    SubOptions.AddFusedActivationFunction(builder, fused_activation_function);
    return SubOptions.EndSubOptions(builder);
  }

  public static void StartSubOptions(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddFusedActivationFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fusedActivationFunction) { builder.AddSbyte(0, (sbyte)fusedActivationFunction, 0); }
  public static void AddPotScaleInt16(FlatBufferBuilder builder, bool potScaleInt16) { builder.AddBool(1, potScaleInt16, true); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SubOptions> EndSubOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SubOptions>(o);
  }
}


static class SubOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*FusedActivationFunction*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*PotScaleInt16*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct DivOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static DivOptions GetRootAsDivOptions(ByteBuffer _bb) { return GetRootAsDivOptions(_bb, new DivOptions()); }
  public static DivOptions GetRootAsDivOptions(ByteBuffer _bb, DivOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DivOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType FusedActivationFunction { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.DivOptions> CreateDivOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fused_activation_function = Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE) {
    builder.StartTable(1);
    DivOptions.AddFusedActivationFunction(builder, fused_activation_function);
    return DivOptions.EndDivOptions(builder);
  }

  public static void StartDivOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddFusedActivationFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fusedActivationFunction) { builder.AddSbyte(0, (sbyte)fusedActivationFunction, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.DivOptions> EndDivOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.DivOptions>(o);
  }
}


static class DivOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*FusedActivationFunction*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct TopKV2Options : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static TopKV2Options GetRootAsTopKV2Options(ByteBuffer _bb) { return GetRootAsTopKV2Options(_bb, new TopKV2Options()); }
  public static TopKV2Options GetRootAsTopKV2Options(ByteBuffer _bb, TopKV2Options obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TopKV2Options __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartTopKV2Options(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.TopKV2Options> EndTopKV2Options(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.TopKV2Options>(o);
  }
}


static class TopKV2OptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct EmbeddingLookupSparseOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static EmbeddingLookupSparseOptions GetRootAsEmbeddingLookupSparseOptions(ByteBuffer _bb) { return GetRootAsEmbeddingLookupSparseOptions(_bb, new EmbeddingLookupSparseOptions()); }
  public static EmbeddingLookupSparseOptions GetRootAsEmbeddingLookupSparseOptions(ByteBuffer _bb, EmbeddingLookupSparseOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public EmbeddingLookupSparseOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.CombinerType Combiner { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.CombinerType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.CombinerType.SUM; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.CombinerType combiner = Unity.InferenceEngine.Editor.LiteRT.CombinerType.SUM) {
    builder.StartTable(1);
    EmbeddingLookupSparseOptions.AddCombiner(builder, combiner);
    return EmbeddingLookupSparseOptions.EndEmbeddingLookupSparseOptions(builder);
  }

  public static void StartEmbeddingLookupSparseOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddCombiner(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.CombinerType combiner) { builder.AddSbyte(0, (sbyte)combiner, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.EmbeddingLookupSparseOptions> EndEmbeddingLookupSparseOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.EmbeddingLookupSparseOptions>(o);
  }
}


static class EmbeddingLookupSparseOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Combiner*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.CombinerType*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct GatherOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static GatherOptions GetRootAsGatherOptions(ByteBuffer _bb) { return GetRootAsGatherOptions(_bb, new GatherOptions()); }
  public static GatherOptions GetRootAsGatherOptions(ByteBuffer _bb, GatherOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public GatherOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int Axis { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int BatchDims { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.GatherOptions> CreateGatherOptions(FlatBufferBuilder builder,
      int axis = 0,
      int batch_dims = 0) {
    builder.StartTable(2);
    GatherOptions.AddBatchDims(builder, batch_dims);
    GatherOptions.AddAxis(builder, axis);
    return GatherOptions.EndGatherOptions(builder);
  }

  public static void StartGatherOptions(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddAxis(FlatBufferBuilder builder, int axis) { builder.AddInt(0, axis, 0); }
  public static void AddBatchDims(FlatBufferBuilder builder, int batchDims) { builder.AddInt(1, batchDims, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.GatherOptions> EndGatherOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.GatherOptions>(o);
  }
}


static class GatherOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Axis*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*BatchDims*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct TransposeOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static TransposeOptions GetRootAsTransposeOptions(ByteBuffer _bb) { return GetRootAsTransposeOptions(_bb, new TransposeOptions()); }
  public static TransposeOptions GetRootAsTransposeOptions(ByteBuffer _bb, TransposeOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TransposeOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartTransposeOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.TransposeOptions> EndTransposeOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.TransposeOptions>(o);
  }
}


static class TransposeOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct ExpOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ExpOptions GetRootAsExpOptions(ByteBuffer _bb) { return GetRootAsExpOptions(_bb, new ExpOptions()); }
  public static ExpOptions GetRootAsExpOptions(ByteBuffer _bb, ExpOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ExpOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartExpOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ExpOptions> EndExpOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.ExpOptions>(o);
  }
}


static class ExpOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct CosOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static CosOptions GetRootAsCosOptions(ByteBuffer _bb) { return GetRootAsCosOptions(_bb, new CosOptions()); }
  public static CosOptions GetRootAsCosOptions(ByteBuffer _bb, CosOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public CosOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartCosOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.CosOptions> EndCosOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.CosOptions>(o);
  }
}


static class CosOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct ReducerOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ReducerOptions GetRootAsReducerOptions(ByteBuffer _bb) { return GetRootAsReducerOptions(_bb, new ReducerOptions()); }
  public static ReducerOptions GetRootAsReducerOptions(ByteBuffer _bb, ReducerOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ReducerOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool KeepDims { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ReducerOptions> CreateReducerOptions(FlatBufferBuilder builder,
      bool keep_dims = false) {
    builder.StartTable(1);
    ReducerOptions.AddKeepDims(builder, keep_dims);
    return ReducerOptions.EndReducerOptions(builder);
  }

  public static void StartReducerOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddKeepDims(FlatBufferBuilder builder, bool keepDims) { builder.AddBool(0, keepDims, false); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ReducerOptions> EndReducerOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.ReducerOptions>(o);
  }
}


static class ReducerOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*KeepDims*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SqueezeOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SqueezeOptions GetRootAsSqueezeOptions(ByteBuffer _bb) { return GetRootAsSqueezeOptions(_bb, new SqueezeOptions()); }
  public static SqueezeOptions GetRootAsSqueezeOptions(ByteBuffer _bb, SqueezeOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SqueezeOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int SqueezeDims(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int SqueezeDimsLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetSqueezeDimsBytes() { return __p.__vector_as_span<int>(4, 4); }
#else
  public ArraySegment<byte>? GetSqueezeDimsBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public int[] GetSqueezeDimsArray() { return __p.__vector_as_array<int>(4); }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SqueezeOptions> CreateSqueezeOptions(FlatBufferBuilder builder,
      VectorOffset squeeze_dimsOffset = default(VectorOffset)) {
    builder.StartTable(1);
    SqueezeOptions.AddSqueezeDims(builder, squeeze_dimsOffset);
    return SqueezeOptions.EndSqueezeOptions(builder);
  }

  public static void StartSqueezeOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddSqueezeDims(FlatBufferBuilder builder, VectorOffset squeezeDimsOffset) { builder.AddOffset(0, squeezeDimsOffset.Value, 0); }
  public static VectorOffset CreateSqueezeDimsVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateSqueezeDimsVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSqueezeDimsVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSqueezeDimsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSqueezeDimsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SqueezeOptions> EndSqueezeOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SqueezeOptions>(o);
  }
}


static class SqueezeOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*SqueezeDims*/, 4 /*int*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SplitOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SplitOptions GetRootAsSplitOptions(ByteBuffer _bb) { return GetRootAsSplitOptions(_bb, new SplitOptions()); }
  public static SplitOptions GetRootAsSplitOptions(ByteBuffer _bb, SplitOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SplitOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int NumSplits { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SplitOptions> CreateSplitOptions(FlatBufferBuilder builder,
      int num_splits = 0) {
    builder.StartTable(1);
    SplitOptions.AddNumSplits(builder, num_splits);
    return SplitOptions.EndSplitOptions(builder);
  }

  public static void StartSplitOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddNumSplits(FlatBufferBuilder builder, int numSplits) { builder.AddInt(0, numSplits, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SplitOptions> EndSplitOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SplitOptions>(o);
  }
}


static class SplitOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*NumSplits*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SplitVOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SplitVOptions GetRootAsSplitVOptions(ByteBuffer _bb) { return GetRootAsSplitVOptions(_bb, new SplitVOptions()); }
  public static SplitVOptions GetRootAsSplitVOptions(ByteBuffer _bb, SplitVOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SplitVOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int NumSplits { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SplitVOptions> CreateSplitVOptions(FlatBufferBuilder builder,
      int num_splits = 0) {
    builder.StartTable(1);
    SplitVOptions.AddNumSplits(builder, num_splits);
    return SplitVOptions.EndSplitVOptions(builder);
  }

  public static void StartSplitVOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddNumSplits(FlatBufferBuilder builder, int numSplits) { builder.AddInt(0, numSplits, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SplitVOptions> EndSplitVOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SplitVOptions>(o);
  }
}


static class SplitVOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*NumSplits*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StridedSliceOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StridedSliceOptions GetRootAsStridedSliceOptions(ByteBuffer _bb) { return GetRootAsStridedSliceOptions(_bb, new StridedSliceOptions()); }
  public static StridedSliceOptions GetRootAsStridedSliceOptions(ByteBuffer _bb, StridedSliceOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StridedSliceOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int BeginMask { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int EndMask { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int EllipsisMask { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int NewAxisMask { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int ShrinkAxisMask { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public bool Offset { get { int o = __p.__offset(14); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StridedSliceOptions> CreateStridedSliceOptions(FlatBufferBuilder builder,
      int begin_mask = 0,
      int end_mask = 0,
      int ellipsis_mask = 0,
      int new_axis_mask = 0,
      int shrink_axis_mask = 0,
      bool offset = false) {
    builder.StartTable(6);
    StridedSliceOptions.AddShrinkAxisMask(builder, shrink_axis_mask);
    StridedSliceOptions.AddNewAxisMask(builder, new_axis_mask);
    StridedSliceOptions.AddEllipsisMask(builder, ellipsis_mask);
    StridedSliceOptions.AddEndMask(builder, end_mask);
    StridedSliceOptions.AddBeginMask(builder, begin_mask);
    StridedSliceOptions.AddOffset(builder, offset);
    return StridedSliceOptions.EndStridedSliceOptions(builder);
  }

  public static void StartStridedSliceOptions(FlatBufferBuilder builder) { builder.StartTable(6); }
  public static void AddBeginMask(FlatBufferBuilder builder, int beginMask) { builder.AddInt(0, beginMask, 0); }
  public static void AddEndMask(FlatBufferBuilder builder, int endMask) { builder.AddInt(1, endMask, 0); }
  public static void AddEllipsisMask(FlatBufferBuilder builder, int ellipsisMask) { builder.AddInt(2, ellipsisMask, 0); }
  public static void AddNewAxisMask(FlatBufferBuilder builder, int newAxisMask) { builder.AddInt(3, newAxisMask, 0); }
  public static void AddShrinkAxisMask(FlatBufferBuilder builder, int shrinkAxisMask) { builder.AddInt(4, shrinkAxisMask, 0); }
  public static void AddOffset(FlatBufferBuilder builder, bool offset) { builder.AddBool(5, offset, false); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StridedSliceOptions> EndStridedSliceOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StridedSliceOptions>(o);
  }
}


static class StridedSliceOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*BeginMask*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*EndMask*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*EllipsisMask*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*NewAxisMask*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 12 /*ShrinkAxisMask*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 14 /*Offset*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct LogSoftmaxOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static LogSoftmaxOptions GetRootAsLogSoftmaxOptions(ByteBuffer _bb) { return GetRootAsLogSoftmaxOptions(_bb, new LogSoftmaxOptions()); }
  public static LogSoftmaxOptions GetRootAsLogSoftmaxOptions(ByteBuffer _bb, LogSoftmaxOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public LogSoftmaxOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartLogSoftmaxOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.LogSoftmaxOptions> EndLogSoftmaxOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.LogSoftmaxOptions>(o);
  }
}


static class LogSoftmaxOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct CastOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static CastOptions GetRootAsCastOptions(ByteBuffer _bb) { return GetRootAsCastOptions(_bb, new CastOptions()); }
  public static CastOptions GetRootAsCastOptions(ByteBuffer _bb, CastOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public CastOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.TensorType InDataType { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.TensorType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32; } }
  public Unity.InferenceEngine.Editor.LiteRT.TensorType OutDataType { get { int o = __p.__offset(6); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.TensorType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.CastOptions> CreateCastOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.TensorType in_data_type = Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32,
      Unity.InferenceEngine.Editor.LiteRT.TensorType out_data_type = Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32) {
    builder.StartTable(2);
    CastOptions.AddOutDataType(builder, out_data_type);
    CastOptions.AddInDataType(builder, in_data_type);
    return CastOptions.EndCastOptions(builder);
  }

  public static void StartCastOptions(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddInDataType(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.TensorType inDataType) { builder.AddSbyte(0, (sbyte)inDataType, 0); }
  public static void AddOutDataType(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.TensorType outDataType) { builder.AddSbyte(1, (sbyte)outDataType, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.CastOptions> EndCastOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.CastOptions>(o);
  }
}


static class CastOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*InDataType*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.TensorType*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*OutDataType*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.TensorType*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct DequantizeOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static DequantizeOptions GetRootAsDequantizeOptions(ByteBuffer _bb) { return GetRootAsDequantizeOptions(_bb, new DequantizeOptions()); }
  public static DequantizeOptions GetRootAsDequantizeOptions(ByteBuffer _bb, DequantizeOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DequantizeOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartDequantizeOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.DequantizeOptions> EndDequantizeOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.DequantizeOptions>(o);
  }
}


static class DequantizeOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct MaximumMinimumOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static MaximumMinimumOptions GetRootAsMaximumMinimumOptions(ByteBuffer _bb) { return GetRootAsMaximumMinimumOptions(_bb, new MaximumMinimumOptions()); }
  public static MaximumMinimumOptions GetRootAsMaximumMinimumOptions(ByteBuffer _bb, MaximumMinimumOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public MaximumMinimumOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartMaximumMinimumOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.MaximumMinimumOptions> EndMaximumMinimumOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.MaximumMinimumOptions>(o);
  }
}


static class MaximumMinimumOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct TileOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static TileOptions GetRootAsTileOptions(ByteBuffer _bb) { return GetRootAsTileOptions(_bb, new TileOptions()); }
  public static TileOptions GetRootAsTileOptions(ByteBuffer _bb, TileOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TileOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartTileOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.TileOptions> EndTileOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.TileOptions>(o);
  }
}


static class TileOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct ArgMaxOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ArgMaxOptions GetRootAsArgMaxOptions(ByteBuffer _bb) { return GetRootAsArgMaxOptions(_bb, new ArgMaxOptions()); }
  public static ArgMaxOptions GetRootAsArgMaxOptions(ByteBuffer _bb, ArgMaxOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ArgMaxOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.TensorType OutputType { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.TensorType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ArgMaxOptions> CreateArgMaxOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.TensorType output_type = Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32) {
    builder.StartTable(1);
    ArgMaxOptions.AddOutputType(builder, output_type);
    return ArgMaxOptions.EndArgMaxOptions(builder);
  }

  public static void StartArgMaxOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddOutputType(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.TensorType outputType) { builder.AddSbyte(0, (sbyte)outputType, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ArgMaxOptions> EndArgMaxOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.ArgMaxOptions>(o);
  }
}


static class ArgMaxOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*OutputType*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.TensorType*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct ArgMinOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ArgMinOptions GetRootAsArgMinOptions(ByteBuffer _bb) { return GetRootAsArgMinOptions(_bb, new ArgMinOptions()); }
  public static ArgMinOptions GetRootAsArgMinOptions(ByteBuffer _bb, ArgMinOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ArgMinOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.TensorType OutputType { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.TensorType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ArgMinOptions> CreateArgMinOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.TensorType output_type = Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32) {
    builder.StartTable(1);
    ArgMinOptions.AddOutputType(builder, output_type);
    return ArgMinOptions.EndArgMinOptions(builder);
  }

  public static void StartArgMinOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddOutputType(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.TensorType outputType) { builder.AddSbyte(0, (sbyte)outputType, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ArgMinOptions> EndArgMinOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.ArgMinOptions>(o);
  }
}


static class ArgMinOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*OutputType*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.TensorType*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct GreaterOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static GreaterOptions GetRootAsGreaterOptions(ByteBuffer _bb) { return GetRootAsGreaterOptions(_bb, new GreaterOptions()); }
  public static GreaterOptions GetRootAsGreaterOptions(ByteBuffer _bb, GreaterOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public GreaterOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartGreaterOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.GreaterOptions> EndGreaterOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.GreaterOptions>(o);
  }
}


static class GreaterOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct GreaterEqualOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static GreaterEqualOptions GetRootAsGreaterEqualOptions(ByteBuffer _bb) { return GetRootAsGreaterEqualOptions(_bb, new GreaterEqualOptions()); }
  public static GreaterEqualOptions GetRootAsGreaterEqualOptions(ByteBuffer _bb, GreaterEqualOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public GreaterEqualOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartGreaterEqualOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.GreaterEqualOptions> EndGreaterEqualOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.GreaterEqualOptions>(o);
  }
}


static class GreaterEqualOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct LessOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static LessOptions GetRootAsLessOptions(ByteBuffer _bb) { return GetRootAsLessOptions(_bb, new LessOptions()); }
  public static LessOptions GetRootAsLessOptions(ByteBuffer _bb, LessOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public LessOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartLessOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.LessOptions> EndLessOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.LessOptions>(o);
  }
}


static class LessOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct LessEqualOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static LessEqualOptions GetRootAsLessEqualOptions(ByteBuffer _bb) { return GetRootAsLessEqualOptions(_bb, new LessEqualOptions()); }
  public static LessEqualOptions GetRootAsLessEqualOptions(ByteBuffer _bb, LessEqualOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public LessEqualOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartLessEqualOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.LessEqualOptions> EndLessEqualOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.LessEqualOptions>(o);
  }
}


static class LessEqualOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct NegOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static NegOptions GetRootAsNegOptions(ByteBuffer _bb) { return GetRootAsNegOptions(_bb, new NegOptions()); }
  public static NegOptions GetRootAsNegOptions(ByteBuffer _bb, NegOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public NegOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartNegOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.NegOptions> EndNegOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.NegOptions>(o);
  }
}


static class NegOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SelectOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SelectOptions GetRootAsSelectOptions(ByteBuffer _bb) { return GetRootAsSelectOptions(_bb, new SelectOptions()); }
  public static SelectOptions GetRootAsSelectOptions(ByteBuffer _bb, SelectOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SelectOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartSelectOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SelectOptions> EndSelectOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SelectOptions>(o);
  }
}


static class SelectOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SliceOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SliceOptions GetRootAsSliceOptions(ByteBuffer _bb) { return GetRootAsSliceOptions(_bb, new SliceOptions()); }
  public static SliceOptions GetRootAsSliceOptions(ByteBuffer _bb, SliceOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SliceOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartSliceOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SliceOptions> EndSliceOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SliceOptions>(o);
  }
}


static class SliceOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct TransposeConvOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static TransposeConvOptions GetRootAsTransposeConvOptions(ByteBuffer _bb) { return GetRootAsTransposeConvOptions(_bb, new TransposeConvOptions()); }
  public static TransposeConvOptions GetRootAsTransposeConvOptions(ByteBuffer _bb, TransposeConvOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TransposeConvOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.Padding Padding { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.Padding)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.Padding.SAME; } }
  public int StrideW { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int StrideH { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType FusedActivationFunction { get { int o = __p.__offset(10); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE; } }
  public Unity.InferenceEngine.Editor.LiteRT.TensorType QuantizedBiasType { get { int o = __p.__offset(12); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.TensorType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.TransposeConvOptions> CreateTransposeConvOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.Padding padding = Unity.InferenceEngine.Editor.LiteRT.Padding.SAME,
      int stride_w = 0,
      int stride_h = 0,
      Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fused_activation_function = Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType.NONE,
      Unity.InferenceEngine.Editor.LiteRT.TensorType quantized_bias_type = Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32) {
    builder.StartTable(5);
    TransposeConvOptions.AddStrideH(builder, stride_h);
    TransposeConvOptions.AddStrideW(builder, stride_w);
    TransposeConvOptions.AddQuantizedBiasType(builder, quantized_bias_type);
    TransposeConvOptions.AddFusedActivationFunction(builder, fused_activation_function);
    TransposeConvOptions.AddPadding(builder, padding);
    return TransposeConvOptions.EndTransposeConvOptions(builder);
  }

  public static void StartTransposeConvOptions(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddPadding(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.Padding padding) { builder.AddSbyte(0, (sbyte)padding, 0); }
  public static void AddStrideW(FlatBufferBuilder builder, int strideW) { builder.AddInt(1, strideW, 0); }
  public static void AddStrideH(FlatBufferBuilder builder, int strideH) { builder.AddInt(2, strideH, 0); }
  public static void AddFusedActivationFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType fusedActivationFunction) { builder.AddSbyte(3, (sbyte)fusedActivationFunction, 0); }
  public static void AddQuantizedBiasType(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.TensorType quantizedBiasType) { builder.AddSbyte(4, (sbyte)quantizedBiasType, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.TransposeConvOptions> EndTransposeConvOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.TransposeConvOptions>(o);
  }
}


static class TransposeConvOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Padding*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.Padding*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*StrideW*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*StrideH*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*FusedActivationFunction*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.ActivationFunctionType*/, 1, false)
      && verifier.VerifyField(tablePos, 12 /*QuantizedBiasType*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.TensorType*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct ExpandDimsOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ExpandDimsOptions GetRootAsExpandDimsOptions(ByteBuffer _bb) { return GetRootAsExpandDimsOptions(_bb, new ExpandDimsOptions()); }
  public static ExpandDimsOptions GetRootAsExpandDimsOptions(ByteBuffer _bb, ExpandDimsOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ExpandDimsOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartExpandDimsOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ExpandDimsOptions> EndExpandDimsOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.ExpandDimsOptions>(o);
  }
}


static class ExpandDimsOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SparseToDenseOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SparseToDenseOptions GetRootAsSparseToDenseOptions(ByteBuffer _bb) { return GetRootAsSparseToDenseOptions(_bb, new SparseToDenseOptions()); }
  public static SparseToDenseOptions GetRootAsSparseToDenseOptions(ByteBuffer _bb, SparseToDenseOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SparseToDenseOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool ValidateIndices { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SparseToDenseOptions> CreateSparseToDenseOptions(FlatBufferBuilder builder,
      bool validate_indices = false) {
    builder.StartTable(1);
    SparseToDenseOptions.AddValidateIndices(builder, validate_indices);
    return SparseToDenseOptions.EndSparseToDenseOptions(builder);
  }

  public static void StartSparseToDenseOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddValidateIndices(FlatBufferBuilder builder, bool validateIndices) { builder.AddBool(0, validateIndices, false); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SparseToDenseOptions> EndSparseToDenseOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SparseToDenseOptions>(o);
  }
}


static class SparseToDenseOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*ValidateIndices*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct EqualOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static EqualOptions GetRootAsEqualOptions(ByteBuffer _bb) { return GetRootAsEqualOptions(_bb, new EqualOptions()); }
  public static EqualOptions GetRootAsEqualOptions(ByteBuffer _bb, EqualOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public EqualOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartEqualOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.EqualOptions> EndEqualOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.EqualOptions>(o);
  }
}


static class EqualOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct NotEqualOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static NotEqualOptions GetRootAsNotEqualOptions(ByteBuffer _bb) { return GetRootAsNotEqualOptions(_bb, new NotEqualOptions()); }
  public static NotEqualOptions GetRootAsNotEqualOptions(ByteBuffer _bb, NotEqualOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public NotEqualOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartNotEqualOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.NotEqualOptions> EndNotEqualOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.NotEqualOptions>(o);
  }
}


static class NotEqualOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct ShapeOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ShapeOptions GetRootAsShapeOptions(ByteBuffer _bb) { return GetRootAsShapeOptions(_bb, new ShapeOptions()); }
  public static ShapeOptions GetRootAsShapeOptions(ByteBuffer _bb, ShapeOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ShapeOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.TensorType OutType { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.TensorType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ShapeOptions> CreateShapeOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.TensorType out_type = Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32) {
    builder.StartTable(1);
    ShapeOptions.AddOutType(builder, out_type);
    return ShapeOptions.EndShapeOptions(builder);
  }

  public static void StartShapeOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddOutType(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.TensorType outType) { builder.AddSbyte(0, (sbyte)outType, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ShapeOptions> EndShapeOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.ShapeOptions>(o);
  }
}


static class ShapeOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*OutType*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.TensorType*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct RankOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static RankOptions GetRootAsRankOptions(ByteBuffer _bb) { return GetRootAsRankOptions(_bb, new RankOptions()); }
  public static RankOptions GetRootAsRankOptions(ByteBuffer _bb, RankOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RankOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartRankOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.RankOptions> EndRankOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.RankOptions>(o);
  }
}


static class RankOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct PowOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static PowOptions GetRootAsPowOptions(ByteBuffer _bb) { return GetRootAsPowOptions(_bb, new PowOptions()); }
  public static PowOptions GetRootAsPowOptions(ByteBuffer _bb, PowOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PowOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartPowOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.PowOptions> EndPowOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.PowOptions>(o);
  }
}


static class PowOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct FakeQuantOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static FakeQuantOptions GetRootAsFakeQuantOptions(ByteBuffer _bb) { return GetRootAsFakeQuantOptions(_bb, new FakeQuantOptions()); }
  public static FakeQuantOptions GetRootAsFakeQuantOptions(ByteBuffer _bb, FakeQuantOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public FakeQuantOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float Min { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float Max { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public int NumBits { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public bool NarrowRange { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.FakeQuantOptions> CreateFakeQuantOptions(FlatBufferBuilder builder,
      float min = 0.0f,
      float max = 0.0f,
      int num_bits = 0,
      bool narrow_range = false) {
    builder.StartTable(4);
    FakeQuantOptions.AddNumBits(builder, num_bits);
    FakeQuantOptions.AddMax(builder, max);
    FakeQuantOptions.AddMin(builder, min);
    FakeQuantOptions.AddNarrowRange(builder, narrow_range);
    return FakeQuantOptions.EndFakeQuantOptions(builder);
  }

  public static void StartFakeQuantOptions(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddMin(FlatBufferBuilder builder, float min) { builder.AddFloat(0, min, 0.0f); }
  public static void AddMax(FlatBufferBuilder builder, float max) { builder.AddFloat(1, max, 0.0f); }
  public static void AddNumBits(FlatBufferBuilder builder, int numBits) { builder.AddInt(2, numBits, 0); }
  public static void AddNarrowRange(FlatBufferBuilder builder, bool narrowRange) { builder.AddBool(3, narrowRange, false); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.FakeQuantOptions> EndFakeQuantOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.FakeQuantOptions>(o);
  }
}


static class FakeQuantOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Min*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Max*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*NumBits*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*NarrowRange*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct PackOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static PackOptions GetRootAsPackOptions(ByteBuffer _bb) { return GetRootAsPackOptions(_bb, new PackOptions()); }
  public static PackOptions GetRootAsPackOptions(ByteBuffer _bb, PackOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PackOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int ValuesCount { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int Axis { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.PackOptions> CreatePackOptions(FlatBufferBuilder builder,
      int values_count = 0,
      int axis = 0) {
    builder.StartTable(2);
    PackOptions.AddAxis(builder, axis);
    PackOptions.AddValuesCount(builder, values_count);
    return PackOptions.EndPackOptions(builder);
  }

  public static void StartPackOptions(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddValuesCount(FlatBufferBuilder builder, int valuesCount) { builder.AddInt(0, valuesCount, 0); }
  public static void AddAxis(FlatBufferBuilder builder, int axis) { builder.AddInt(1, axis, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.PackOptions> EndPackOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.PackOptions>(o);
  }
}


static class PackOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*ValuesCount*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Axis*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct LogicalOrOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static LogicalOrOptions GetRootAsLogicalOrOptions(ByteBuffer _bb) { return GetRootAsLogicalOrOptions(_bb, new LogicalOrOptions()); }
  public static LogicalOrOptions GetRootAsLogicalOrOptions(ByteBuffer _bb, LogicalOrOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public LogicalOrOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartLogicalOrOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.LogicalOrOptions> EndLogicalOrOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.LogicalOrOptions>(o);
  }
}


static class LogicalOrOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct OneHotOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static OneHotOptions GetRootAsOneHotOptions(ByteBuffer _bb) { return GetRootAsOneHotOptions(_bb, new OneHotOptions()); }
  public static OneHotOptions GetRootAsOneHotOptions(ByteBuffer _bb, OneHotOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public OneHotOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int Axis { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.OneHotOptions> CreateOneHotOptions(FlatBufferBuilder builder,
      int axis = 0) {
    builder.StartTable(1);
    OneHotOptions.AddAxis(builder, axis);
    return OneHotOptions.EndOneHotOptions(builder);
  }

  public static void StartOneHotOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddAxis(FlatBufferBuilder builder, int axis) { builder.AddInt(0, axis, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.OneHotOptions> EndOneHotOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.OneHotOptions>(o);
  }
}


static class OneHotOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Axis*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct AbsOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static AbsOptions GetRootAsAbsOptions(ByteBuffer _bb) { return GetRootAsAbsOptions(_bb, new AbsOptions()); }
  public static AbsOptions GetRootAsAbsOptions(ByteBuffer _bb, AbsOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public AbsOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartAbsOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.AbsOptions> EndAbsOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.AbsOptions>(o);
  }
}


static class AbsOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct HardSwishOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static HardSwishOptions GetRootAsHardSwishOptions(ByteBuffer _bb) { return GetRootAsHardSwishOptions(_bb, new HardSwishOptions()); }
  public static HardSwishOptions GetRootAsHardSwishOptions(ByteBuffer _bb, HardSwishOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public HardSwishOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartHardSwishOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.HardSwishOptions> EndHardSwishOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.HardSwishOptions>(o);
  }
}


static class HardSwishOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct LogicalAndOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static LogicalAndOptions GetRootAsLogicalAndOptions(ByteBuffer _bb) { return GetRootAsLogicalAndOptions(_bb, new LogicalAndOptions()); }
  public static LogicalAndOptions GetRootAsLogicalAndOptions(ByteBuffer _bb, LogicalAndOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public LogicalAndOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartLogicalAndOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.LogicalAndOptions> EndLogicalAndOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.LogicalAndOptions>(o);
  }
}


static class LogicalAndOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct LogicalNotOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static LogicalNotOptions GetRootAsLogicalNotOptions(ByteBuffer _bb) { return GetRootAsLogicalNotOptions(_bb, new LogicalNotOptions()); }
  public static LogicalNotOptions GetRootAsLogicalNotOptions(ByteBuffer _bb, LogicalNotOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public LogicalNotOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartLogicalNotOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.LogicalNotOptions> EndLogicalNotOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.LogicalNotOptions>(o);
  }
}


static class LogicalNotOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct UnpackOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static UnpackOptions GetRootAsUnpackOptions(ByteBuffer _bb) { return GetRootAsUnpackOptions(_bb, new UnpackOptions()); }
  public static UnpackOptions GetRootAsUnpackOptions(ByteBuffer _bb, UnpackOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public UnpackOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int Num { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int Axis { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.UnpackOptions> CreateUnpackOptions(FlatBufferBuilder builder,
      int num = 0,
      int axis = 0) {
    builder.StartTable(2);
    UnpackOptions.AddAxis(builder, axis);
    UnpackOptions.AddNum(builder, num);
    return UnpackOptions.EndUnpackOptions(builder);
  }

  public static void StartUnpackOptions(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddNum(FlatBufferBuilder builder, int num) { builder.AddInt(0, num, 0); }
  public static void AddAxis(FlatBufferBuilder builder, int axis) { builder.AddInt(1, axis, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.UnpackOptions> EndUnpackOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.UnpackOptions>(o);
  }
}


static class UnpackOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Num*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Axis*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct FloorDivOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static FloorDivOptions GetRootAsFloorDivOptions(ByteBuffer _bb) { return GetRootAsFloorDivOptions(_bb, new FloorDivOptions()); }
  public static FloorDivOptions GetRootAsFloorDivOptions(ByteBuffer _bb, FloorDivOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public FloorDivOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartFloorDivOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.FloorDivOptions> EndFloorDivOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.FloorDivOptions>(o);
  }
}


static class FloorDivOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SquareOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SquareOptions GetRootAsSquareOptions(ByteBuffer _bb) { return GetRootAsSquareOptions(_bb, new SquareOptions()); }
  public static SquareOptions GetRootAsSquareOptions(ByteBuffer _bb, SquareOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SquareOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartSquareOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SquareOptions> EndSquareOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SquareOptions>(o);
  }
}


static class SquareOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct ZerosLikeOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ZerosLikeOptions GetRootAsZerosLikeOptions(ByteBuffer _bb) { return GetRootAsZerosLikeOptions(_bb, new ZerosLikeOptions()); }
  public static ZerosLikeOptions GetRootAsZerosLikeOptions(ByteBuffer _bb, ZerosLikeOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ZerosLikeOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartZerosLikeOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ZerosLikeOptions> EndZerosLikeOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.ZerosLikeOptions>(o);
  }
}


static class ZerosLikeOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct FillOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static FillOptions GetRootAsFillOptions(ByteBuffer _bb) { return GetRootAsFillOptions(_bb, new FillOptions()); }
  public static FillOptions GetRootAsFillOptions(ByteBuffer _bb, FillOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public FillOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartFillOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.FillOptions> EndFillOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.FillOptions>(o);
  }
}


static class FillOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct FloorModOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static FloorModOptions GetRootAsFloorModOptions(ByteBuffer _bb) { return GetRootAsFloorModOptions(_bb, new FloorModOptions()); }
  public static FloorModOptions GetRootAsFloorModOptions(ByteBuffer _bb, FloorModOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public FloorModOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartFloorModOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.FloorModOptions> EndFloorModOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.FloorModOptions>(o);
  }
}


static class FloorModOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct RangeOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static RangeOptions GetRootAsRangeOptions(ByteBuffer _bb) { return GetRootAsRangeOptions(_bb, new RangeOptions()); }
  public static RangeOptions GetRootAsRangeOptions(ByteBuffer _bb, RangeOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RangeOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartRangeOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.RangeOptions> EndRangeOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.RangeOptions>(o);
  }
}


static class RangeOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct LeakyReluOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static LeakyReluOptions GetRootAsLeakyReluOptions(ByteBuffer _bb) { return GetRootAsLeakyReluOptions(_bb, new LeakyReluOptions()); }
  public static LeakyReluOptions GetRootAsLeakyReluOptions(ByteBuffer _bb, LeakyReluOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public LeakyReluOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float Alpha { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.LeakyReluOptions> CreateLeakyReluOptions(FlatBufferBuilder builder,
      float alpha = 0.0f) {
    builder.StartTable(1);
    LeakyReluOptions.AddAlpha(builder, alpha);
    return LeakyReluOptions.EndLeakyReluOptions(builder);
  }

  public static void StartLeakyReluOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddAlpha(FlatBufferBuilder builder, float alpha) { builder.AddFloat(0, alpha, 0.0f); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.LeakyReluOptions> EndLeakyReluOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.LeakyReluOptions>(o);
  }
}


static class LeakyReluOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Alpha*/, 4 /*float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SquaredDifferenceOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SquaredDifferenceOptions GetRootAsSquaredDifferenceOptions(ByteBuffer _bb) { return GetRootAsSquaredDifferenceOptions(_bb, new SquaredDifferenceOptions()); }
  public static SquaredDifferenceOptions GetRootAsSquaredDifferenceOptions(ByteBuffer _bb, SquaredDifferenceOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SquaredDifferenceOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartSquaredDifferenceOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SquaredDifferenceOptions> EndSquaredDifferenceOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SquaredDifferenceOptions>(o);
  }
}


static class SquaredDifferenceOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct MirrorPadOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static MirrorPadOptions GetRootAsMirrorPadOptions(ByteBuffer _bb) { return GetRootAsMirrorPadOptions(_bb, new MirrorPadOptions()); }
  public static MirrorPadOptions GetRootAsMirrorPadOptions(ByteBuffer _bb, MirrorPadOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public MirrorPadOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.MirrorPadMode Mode { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.MirrorPadMode)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.MirrorPadMode.REFLECT; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.MirrorPadOptions> CreateMirrorPadOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.MirrorPadMode mode = Unity.InferenceEngine.Editor.LiteRT.MirrorPadMode.REFLECT) {
    builder.StartTable(1);
    MirrorPadOptions.AddMode(builder, mode);
    return MirrorPadOptions.EndMirrorPadOptions(builder);
  }

  public static void StartMirrorPadOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddMode(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.MirrorPadMode mode) { builder.AddSbyte(0, (sbyte)mode, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.MirrorPadOptions> EndMirrorPadOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.MirrorPadOptions>(o);
  }
}


static class MirrorPadOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Mode*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.MirrorPadMode*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct UniqueOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static UniqueOptions GetRootAsUniqueOptions(ByteBuffer _bb) { return GetRootAsUniqueOptions(_bb, new UniqueOptions()); }
  public static UniqueOptions GetRootAsUniqueOptions(ByteBuffer _bb, UniqueOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public UniqueOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.TensorType IdxOutType { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.TensorType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.TensorType.INT32; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.UniqueOptions> CreateUniqueOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.TensorType idx_out_type = Unity.InferenceEngine.Editor.LiteRT.TensorType.INT32) {
    builder.StartTable(1);
    UniqueOptions.AddIdxOutType(builder, idx_out_type);
    return UniqueOptions.EndUniqueOptions(builder);
  }

  public static void StartUniqueOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddIdxOutType(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.TensorType idxOutType) { builder.AddSbyte(0, (sbyte)idxOutType, 2); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.UniqueOptions> EndUniqueOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.UniqueOptions>(o);
  }
}


static class UniqueOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*IdxOutType*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.TensorType*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct ReverseV2Options : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ReverseV2Options GetRootAsReverseV2Options(ByteBuffer _bb) { return GetRootAsReverseV2Options(_bb, new ReverseV2Options()); }
  public static ReverseV2Options GetRootAsReverseV2Options(ByteBuffer _bb, ReverseV2Options obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ReverseV2Options __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartReverseV2Options(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ReverseV2Options> EndReverseV2Options(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.ReverseV2Options>(o);
  }
}


static class ReverseV2OptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct AddNOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static AddNOptions GetRootAsAddNOptions(ByteBuffer _bb) { return GetRootAsAddNOptions(_bb, new AddNOptions()); }
  public static AddNOptions GetRootAsAddNOptions(ByteBuffer _bb, AddNOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public AddNOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartAddNOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.AddNOptions> EndAddNOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.AddNOptions>(o);
  }
}


static class AddNOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct GatherNdOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static GatherNdOptions GetRootAsGatherNdOptions(ByteBuffer _bb) { return GetRootAsGatherNdOptions(_bb, new GatherNdOptions()); }
  public static GatherNdOptions GetRootAsGatherNdOptions(ByteBuffer _bb, GatherNdOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public GatherNdOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartGatherNdOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.GatherNdOptions> EndGatherNdOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.GatherNdOptions>(o);
  }
}


static class GatherNdOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct WhereOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static WhereOptions GetRootAsWhereOptions(ByteBuffer _bb) { return GetRootAsWhereOptions(_bb, new WhereOptions()); }
  public static WhereOptions GetRootAsWhereOptions(ByteBuffer _bb, WhereOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public WhereOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartWhereOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.WhereOptions> EndWhereOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.WhereOptions>(o);
  }
}


static class WhereOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct ReverseSequenceOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ReverseSequenceOptions GetRootAsReverseSequenceOptions(ByteBuffer _bb) { return GetRootAsReverseSequenceOptions(_bb, new ReverseSequenceOptions()); }
  public static ReverseSequenceOptions GetRootAsReverseSequenceOptions(ByteBuffer _bb, ReverseSequenceOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ReverseSequenceOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int SeqDim { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int BatchDim { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ReverseSequenceOptions> CreateReverseSequenceOptions(FlatBufferBuilder builder,
      int seq_dim = 0,
      int batch_dim = 0) {
    builder.StartTable(2);
    ReverseSequenceOptions.AddBatchDim(builder, batch_dim);
    ReverseSequenceOptions.AddSeqDim(builder, seq_dim);
    return ReverseSequenceOptions.EndReverseSequenceOptions(builder);
  }

  public static void StartReverseSequenceOptions(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddSeqDim(FlatBufferBuilder builder, int seqDim) { builder.AddInt(0, seqDim, 0); }
  public static void AddBatchDim(FlatBufferBuilder builder, int batchDim) { builder.AddInt(1, batchDim, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ReverseSequenceOptions> EndReverseSequenceOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.ReverseSequenceOptions>(o);
  }
}


static class ReverseSequenceOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*SeqDim*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*BatchDim*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct MatrixDiagOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static MatrixDiagOptions GetRootAsMatrixDiagOptions(ByteBuffer _bb) { return GetRootAsMatrixDiagOptions(_bb, new MatrixDiagOptions()); }
  public static MatrixDiagOptions GetRootAsMatrixDiagOptions(ByteBuffer _bb, MatrixDiagOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public MatrixDiagOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartMatrixDiagOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.MatrixDiagOptions> EndMatrixDiagOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.MatrixDiagOptions>(o);
  }
}


static class MatrixDiagOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct QuantizeOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static QuantizeOptions GetRootAsQuantizeOptions(ByteBuffer _bb) { return GetRootAsQuantizeOptions(_bb, new QuantizeOptions()); }
  public static QuantizeOptions GetRootAsQuantizeOptions(ByteBuffer _bb, QuantizeOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public QuantizeOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartQuantizeOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.QuantizeOptions> EndQuantizeOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.QuantizeOptions>(o);
  }
}


static class QuantizeOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct MatrixSetDiagOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static MatrixSetDiagOptions GetRootAsMatrixSetDiagOptions(ByteBuffer _bb) { return GetRootAsMatrixSetDiagOptions(_bb, new MatrixSetDiagOptions()); }
  public static MatrixSetDiagOptions GetRootAsMatrixSetDiagOptions(ByteBuffer _bb, MatrixSetDiagOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public MatrixSetDiagOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartMatrixSetDiagOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.MatrixSetDiagOptions> EndMatrixSetDiagOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.MatrixSetDiagOptions>(o);
  }
}


static class MatrixSetDiagOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct IfOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static IfOptions GetRootAsIfOptions(ByteBuffer _bb) { return GetRootAsIfOptions(_bb, new IfOptions()); }
  public static IfOptions GetRootAsIfOptions(ByteBuffer _bb, IfOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public IfOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int ThenSubgraphIndex { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int ElseSubgraphIndex { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.IfOptions> CreateIfOptions(FlatBufferBuilder builder,
      int then_subgraph_index = 0,
      int else_subgraph_index = 0) {
    builder.StartTable(2);
    IfOptions.AddElseSubgraphIndex(builder, else_subgraph_index);
    IfOptions.AddThenSubgraphIndex(builder, then_subgraph_index);
    return IfOptions.EndIfOptions(builder);
  }

  public static void StartIfOptions(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddThenSubgraphIndex(FlatBufferBuilder builder, int thenSubgraphIndex) { builder.AddInt(0, thenSubgraphIndex, 0); }
  public static void AddElseSubgraphIndex(FlatBufferBuilder builder, int elseSubgraphIndex) { builder.AddInt(1, elseSubgraphIndex, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.IfOptions> EndIfOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.IfOptions>(o);
  }
}


static class IfOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*ThenSubgraphIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*ElseSubgraphIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct CallOnceOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static CallOnceOptions GetRootAsCallOnceOptions(ByteBuffer _bb) { return GetRootAsCallOnceOptions(_bb, new CallOnceOptions()); }
  public static CallOnceOptions GetRootAsCallOnceOptions(ByteBuffer _bb, CallOnceOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public CallOnceOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int InitSubgraphIndex { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.CallOnceOptions> CreateCallOnceOptions(FlatBufferBuilder builder,
      int init_subgraph_index = 0) {
    builder.StartTable(1);
    CallOnceOptions.AddInitSubgraphIndex(builder, init_subgraph_index);
    return CallOnceOptions.EndCallOnceOptions(builder);
  }

  public static void StartCallOnceOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddInitSubgraphIndex(FlatBufferBuilder builder, int initSubgraphIndex) { builder.AddInt(0, initSubgraphIndex, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.CallOnceOptions> EndCallOnceOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.CallOnceOptions>(o);
  }
}


static class CallOnceOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*InitSubgraphIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct WhileOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static WhileOptions GetRootAsWhileOptions(ByteBuffer _bb) { return GetRootAsWhileOptions(_bb, new WhileOptions()); }
  public static WhileOptions GetRootAsWhileOptions(ByteBuffer _bb, WhileOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public WhileOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int CondSubgraphIndex { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int BodySubgraphIndex { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.WhileOptions> CreateWhileOptions(FlatBufferBuilder builder,
      int cond_subgraph_index = 0,
      int body_subgraph_index = 0) {
    builder.StartTable(2);
    WhileOptions.AddBodySubgraphIndex(builder, body_subgraph_index);
    WhileOptions.AddCondSubgraphIndex(builder, cond_subgraph_index);
    return WhileOptions.EndWhileOptions(builder);
  }

  public static void StartWhileOptions(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddCondSubgraphIndex(FlatBufferBuilder builder, int condSubgraphIndex) { builder.AddInt(0, condSubgraphIndex, 0); }
  public static void AddBodySubgraphIndex(FlatBufferBuilder builder, int bodySubgraphIndex) { builder.AddInt(1, bodySubgraphIndex, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.WhileOptions> EndWhileOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.WhileOptions>(o);
  }
}


static class WhileOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*CondSubgraphIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*BodySubgraphIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct NonMaxSuppressionV4Options : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static NonMaxSuppressionV4Options GetRootAsNonMaxSuppressionV4Options(ByteBuffer _bb) { return GetRootAsNonMaxSuppressionV4Options(_bb, new NonMaxSuppressionV4Options()); }
  public static NonMaxSuppressionV4Options GetRootAsNonMaxSuppressionV4Options(ByteBuffer _bb, NonMaxSuppressionV4Options obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public NonMaxSuppressionV4Options __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartNonMaxSuppressionV4Options(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.NonMaxSuppressionV4Options> EndNonMaxSuppressionV4Options(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.NonMaxSuppressionV4Options>(o);
  }
}


static class NonMaxSuppressionV4OptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct NonMaxSuppressionV5Options : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static NonMaxSuppressionV5Options GetRootAsNonMaxSuppressionV5Options(ByteBuffer _bb) { return GetRootAsNonMaxSuppressionV5Options(_bb, new NonMaxSuppressionV5Options()); }
  public static NonMaxSuppressionV5Options GetRootAsNonMaxSuppressionV5Options(ByteBuffer _bb, NonMaxSuppressionV5Options obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public NonMaxSuppressionV5Options __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartNonMaxSuppressionV5Options(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.NonMaxSuppressionV5Options> EndNonMaxSuppressionV5Options(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.NonMaxSuppressionV5Options>(o);
  }
}


static class NonMaxSuppressionV5OptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct ScatterNdOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ScatterNdOptions GetRootAsScatterNdOptions(ByteBuffer _bb) { return GetRootAsScatterNdOptions(_bb, new ScatterNdOptions()); }
  public static ScatterNdOptions GetRootAsScatterNdOptions(ByteBuffer _bb, ScatterNdOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ScatterNdOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartScatterNdOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ScatterNdOptions> EndScatterNdOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.ScatterNdOptions>(o);
  }
}


static class ScatterNdOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SelectV2Options : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SelectV2Options GetRootAsSelectV2Options(ByteBuffer _bb) { return GetRootAsSelectV2Options(_bb, new SelectV2Options()); }
  public static SelectV2Options GetRootAsSelectV2Options(ByteBuffer _bb, SelectV2Options obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SelectV2Options __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartSelectV2Options(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SelectV2Options> EndSelectV2Options(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SelectV2Options>(o);
  }
}


static class SelectV2OptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct DensifyOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static DensifyOptions GetRootAsDensifyOptions(ByteBuffer _bb) { return GetRootAsDensifyOptions(_bb, new DensifyOptions()); }
  public static DensifyOptions GetRootAsDensifyOptions(ByteBuffer _bb, DensifyOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DensifyOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartDensifyOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.DensifyOptions> EndDensifyOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.DensifyOptions>(o);
  }
}


static class DensifyOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SegmentSumOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SegmentSumOptions GetRootAsSegmentSumOptions(ByteBuffer _bb) { return GetRootAsSegmentSumOptions(_bb, new SegmentSumOptions()); }
  public static SegmentSumOptions GetRootAsSegmentSumOptions(ByteBuffer _bb, SegmentSumOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SegmentSumOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartSegmentSumOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SegmentSumOptions> EndSegmentSumOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SegmentSumOptions>(o);
  }
}


static class SegmentSumOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct BatchMatMulOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static BatchMatMulOptions GetRootAsBatchMatMulOptions(ByteBuffer _bb) { return GetRootAsBatchMatMulOptions(_bb, new BatchMatMulOptions()); }
  public static BatchMatMulOptions GetRootAsBatchMatMulOptions(ByteBuffer _bb, BatchMatMulOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BatchMatMulOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool AdjX { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool AdjY { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool AsymmetricQuantizeInputs { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.BatchMatMulOptions> CreateBatchMatMulOptions(FlatBufferBuilder builder,
      bool adj_x = false,
      bool adj_y = false,
      bool asymmetric_quantize_inputs = false) {
    builder.StartTable(3);
    BatchMatMulOptions.AddAsymmetricQuantizeInputs(builder, asymmetric_quantize_inputs);
    BatchMatMulOptions.AddAdjY(builder, adj_y);
    BatchMatMulOptions.AddAdjX(builder, adj_x);
    return BatchMatMulOptions.EndBatchMatMulOptions(builder);
  }

  public static void StartBatchMatMulOptions(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddAdjX(FlatBufferBuilder builder, bool adjX) { builder.AddBool(0, adjX, false); }
  public static void AddAdjY(FlatBufferBuilder builder, bool adjY) { builder.AddBool(1, adjY, false); }
  public static void AddAsymmetricQuantizeInputs(FlatBufferBuilder builder, bool asymmetricQuantizeInputs) { builder.AddBool(2, asymmetricQuantizeInputs, false); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.BatchMatMulOptions> EndBatchMatMulOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.BatchMatMulOptions>(o);
  }
}


static class BatchMatMulOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*AdjX*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*AdjY*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 8 /*AsymmetricQuantizeInputs*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct CumsumOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static CumsumOptions GetRootAsCumsumOptions(ByteBuffer _bb) { return GetRootAsCumsumOptions(_bb, new CumsumOptions()); }
  public static CumsumOptions GetRootAsCumsumOptions(ByteBuffer _bb, CumsumOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public CumsumOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool Exclusive { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool Reverse { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.CumsumOptions> CreateCumsumOptions(FlatBufferBuilder builder,
      bool exclusive = false,
      bool reverse = false) {
    builder.StartTable(2);
    CumsumOptions.AddReverse(builder, reverse);
    CumsumOptions.AddExclusive(builder, exclusive);
    return CumsumOptions.EndCumsumOptions(builder);
  }

  public static void StartCumsumOptions(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddExclusive(FlatBufferBuilder builder, bool exclusive) { builder.AddBool(0, exclusive, false); }
  public static void AddReverse(FlatBufferBuilder builder, bool reverse) { builder.AddBool(1, reverse, false); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.CumsumOptions> EndCumsumOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.CumsumOptions>(o);
  }
}


static class CumsumOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Exclusive*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*Reverse*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct BroadcastToOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static BroadcastToOptions GetRootAsBroadcastToOptions(ByteBuffer _bb) { return GetRootAsBroadcastToOptions(_bb, new BroadcastToOptions()); }
  public static BroadcastToOptions GetRootAsBroadcastToOptions(ByteBuffer _bb, BroadcastToOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BroadcastToOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartBroadcastToOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.BroadcastToOptions> EndBroadcastToOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.BroadcastToOptions>(o);
  }
}


static class BroadcastToOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct Rfft2dOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static Rfft2dOptions GetRootAsRfft2dOptions(ByteBuffer _bb) { return GetRootAsRfft2dOptions(_bb, new Rfft2dOptions()); }
  public static Rfft2dOptions GetRootAsRfft2dOptions(ByteBuffer _bb, Rfft2dOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Rfft2dOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartRfft2dOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Rfft2dOptions> EndRfft2dOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.Rfft2dOptions>(o);
  }
}


static class Rfft2dOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct HashtableOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static HashtableOptions GetRootAsHashtableOptions(ByteBuffer _bb) { return GetRootAsHashtableOptions(_bb, new HashtableOptions()); }
  public static HashtableOptions GetRootAsHashtableOptions(ByteBuffer _bb, HashtableOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public HashtableOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int TableId { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public Unity.InferenceEngine.Editor.LiteRT.TensorType KeyDtype { get { int o = __p.__offset(6); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.TensorType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32; } }
  public Unity.InferenceEngine.Editor.LiteRT.TensorType ValueDtype { get { int o = __p.__offset(8); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.TensorType)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.HashtableOptions> CreateHashtableOptions(FlatBufferBuilder builder,
      int table_id = 0,
      Unity.InferenceEngine.Editor.LiteRT.TensorType key_dtype = Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32,
      Unity.InferenceEngine.Editor.LiteRT.TensorType value_dtype = Unity.InferenceEngine.Editor.LiteRT.TensorType.FLOAT32) {
    builder.StartTable(3);
    HashtableOptions.AddTableId(builder, table_id);
    HashtableOptions.AddValueDtype(builder, value_dtype);
    HashtableOptions.AddKeyDtype(builder, key_dtype);
    return HashtableOptions.EndHashtableOptions(builder);
  }

  public static void StartHashtableOptions(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddTableId(FlatBufferBuilder builder, int tableId) { builder.AddInt(0, tableId, 0); }
  public static void AddKeyDtype(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.TensorType keyDtype) { builder.AddSbyte(1, (sbyte)keyDtype, 0); }
  public static void AddValueDtype(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.TensorType valueDtype) { builder.AddSbyte(2, (sbyte)valueDtype, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.HashtableOptions> EndHashtableOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.HashtableOptions>(o);
  }
}


static class HashtableOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*TableId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*KeyDtype*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.TensorType*/, 1, false)
      && verifier.VerifyField(tablePos, 8 /*ValueDtype*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.TensorType*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct HashtableFindOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static HashtableFindOptions GetRootAsHashtableFindOptions(ByteBuffer _bb) { return GetRootAsHashtableFindOptions(_bb, new HashtableFindOptions()); }
  public static HashtableFindOptions GetRootAsHashtableFindOptions(ByteBuffer _bb, HashtableFindOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public HashtableFindOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartHashtableFindOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.HashtableFindOptions> EndHashtableFindOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.HashtableFindOptions>(o);
  }
}


static class HashtableFindOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct HashtableImportOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static HashtableImportOptions GetRootAsHashtableImportOptions(ByteBuffer _bb) { return GetRootAsHashtableImportOptions(_bb, new HashtableImportOptions()); }
  public static HashtableImportOptions GetRootAsHashtableImportOptions(ByteBuffer _bb, HashtableImportOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public HashtableImportOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartHashtableImportOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.HashtableImportOptions> EndHashtableImportOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.HashtableImportOptions>(o);
  }
}


static class HashtableImportOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct HashtableSizeOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static HashtableSizeOptions GetRootAsHashtableSizeOptions(ByteBuffer _bb) { return GetRootAsHashtableSizeOptions(_bb, new HashtableSizeOptions()); }
  public static HashtableSizeOptions GetRootAsHashtableSizeOptions(ByteBuffer _bb, HashtableSizeOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public HashtableSizeOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartHashtableSizeOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.HashtableSizeOptions> EndHashtableSizeOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.HashtableSizeOptions>(o);
  }
}


static class HashtableSizeOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct VarHandleOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static VarHandleOptions GetRootAsVarHandleOptions(ByteBuffer _bb) { return GetRootAsVarHandleOptions(_bb, new VarHandleOptions()); }
  public static VarHandleOptions GetRootAsVarHandleOptions(ByteBuffer _bb, VarHandleOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public VarHandleOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Container { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetContainerBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetContainerBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetContainerArray() { return __p.__vector_as_array<byte>(4); }
  public string SharedName { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSharedNameBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetSharedNameBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetSharedNameArray() { return __p.__vector_as_array<byte>(6); }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.VarHandleOptions> CreateVarHandleOptions(FlatBufferBuilder builder,
      StringOffset containerOffset = default(StringOffset),
      StringOffset shared_nameOffset = default(StringOffset)) {
    builder.StartTable(2);
    VarHandleOptions.AddSharedName(builder, shared_nameOffset);
    VarHandleOptions.AddContainer(builder, containerOffset);
    return VarHandleOptions.EndVarHandleOptions(builder);
  }

  public static void StartVarHandleOptions(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddContainer(FlatBufferBuilder builder, StringOffset containerOffset) { builder.AddOffset(0, containerOffset.Value, 0); }
  public static void AddSharedName(FlatBufferBuilder builder, StringOffset sharedNameOffset) { builder.AddOffset(1, sharedNameOffset.Value, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.VarHandleOptions> EndVarHandleOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.VarHandleOptions>(o);
  }
}


static class VarHandleOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Container*/, false)
      && verifier.VerifyString(tablePos, 6 /*SharedName*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct ReadVariableOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ReadVariableOptions GetRootAsReadVariableOptions(ByteBuffer _bb) { return GetRootAsReadVariableOptions(_bb, new ReadVariableOptions()); }
  public static ReadVariableOptions GetRootAsReadVariableOptions(ByteBuffer _bb, ReadVariableOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ReadVariableOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartReadVariableOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ReadVariableOptions> EndReadVariableOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.ReadVariableOptions>(o);
  }
}


static class ReadVariableOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct AssignVariableOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static AssignVariableOptions GetRootAsAssignVariableOptions(ByteBuffer _bb) { return GetRootAsAssignVariableOptions(_bb, new AssignVariableOptions()); }
  public static AssignVariableOptions GetRootAsAssignVariableOptions(ByteBuffer _bb, AssignVariableOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public AssignVariableOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartAssignVariableOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.AssignVariableOptions> EndAssignVariableOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.AssignVariableOptions>(o);
  }
}


static class AssignVariableOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct RandomOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static RandomOptions GetRootAsRandomOptions(ByteBuffer _bb) { return GetRootAsRandomOptions(_bb, new RandomOptions()); }
  public static RandomOptions GetRootAsRandomOptions(ByteBuffer _bb, RandomOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RandomOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public long Seed { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public long Seed2 { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.RandomOptions> CreateRandomOptions(FlatBufferBuilder builder,
      long seed = 0,
      long seed2 = 0) {
    builder.StartTable(2);
    RandomOptions.AddSeed2(builder, seed2);
    RandomOptions.AddSeed(builder, seed);
    return RandomOptions.EndRandomOptions(builder);
  }

  public static void StartRandomOptions(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddSeed(FlatBufferBuilder builder, long seed) { builder.AddLong(0, seed, 0); }
  public static void AddSeed2(FlatBufferBuilder builder, long seed2) { builder.AddLong(1, seed2, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.RandomOptions> EndRandomOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.RandomOptions>(o);
  }
}


static class RandomOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Seed*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 6 /*Seed2*/, 8 /*long*/, 8, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct BucketizeOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static BucketizeOptions GetRootAsBucketizeOptions(ByteBuffer _bb) { return GetRootAsBucketizeOptions(_bb, new BucketizeOptions()); }
  public static BucketizeOptions GetRootAsBucketizeOptions(ByteBuffer _bb, BucketizeOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BucketizeOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float Boundaries(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(__p.__vector(o) + j * 4) : (float)0; }
  public int BoundariesLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<float> GetBoundariesBytes() { return __p.__vector_as_span<float>(4, 4); }
#else
  public ArraySegment<byte>? GetBoundariesBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public float[] GetBoundariesArray() { return __p.__vector_as_array<float>(4); }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.BucketizeOptions> CreateBucketizeOptions(FlatBufferBuilder builder,
      VectorOffset boundariesOffset = default(VectorOffset)) {
    builder.StartTable(1);
    BucketizeOptions.AddBoundaries(builder, boundariesOffset);
    return BucketizeOptions.EndBucketizeOptions(builder);
  }

  public static void StartBucketizeOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddBoundaries(FlatBufferBuilder builder, VectorOffset boundariesOffset) { builder.AddOffset(0, boundariesOffset.Value, 0); }
  public static VectorOffset CreateBoundariesVector(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddFloat(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateBoundariesVectorBlock(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBoundariesVectorBlock(FlatBufferBuilder builder, ArraySegment<float> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBoundariesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<float>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartBoundariesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.BucketizeOptions> EndBucketizeOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.BucketizeOptions>(o);
  }
}


static class BucketizeOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*Boundaries*/, 4 /*float*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct GeluOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static GeluOptions GetRootAsGeluOptions(ByteBuffer _bb) { return GetRootAsGeluOptions(_bb, new GeluOptions()); }
  public static GeluOptions GetRootAsGeluOptions(ByteBuffer _bb, GeluOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public GeluOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool Approximate { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.GeluOptions> CreateGeluOptions(FlatBufferBuilder builder,
      bool approximate = false) {
    builder.StartTable(1);
    GeluOptions.AddApproximate(builder, approximate);
    return GeluOptions.EndGeluOptions(builder);
  }

  public static void StartGeluOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddApproximate(FlatBufferBuilder builder, bool approximate) { builder.AddBool(0, approximate, false); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.GeluOptions> EndGeluOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.GeluOptions>(o);
  }
}


static class GeluOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Approximate*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct DynamicUpdateSliceOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static DynamicUpdateSliceOptions GetRootAsDynamicUpdateSliceOptions(ByteBuffer _bb) { return GetRootAsDynamicUpdateSliceOptions(_bb, new DynamicUpdateSliceOptions()); }
  public static DynamicUpdateSliceOptions GetRootAsDynamicUpdateSliceOptions(ByteBuffer _bb, DynamicUpdateSliceOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DynamicUpdateSliceOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartDynamicUpdateSliceOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.DynamicUpdateSliceOptions> EndDynamicUpdateSliceOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.DynamicUpdateSliceOptions>(o);
  }
}


static class DynamicUpdateSliceOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct UnsortedSegmentProdOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static UnsortedSegmentProdOptions GetRootAsUnsortedSegmentProdOptions(ByteBuffer _bb) { return GetRootAsUnsortedSegmentProdOptions(_bb, new UnsortedSegmentProdOptions()); }
  public static UnsortedSegmentProdOptions GetRootAsUnsortedSegmentProdOptions(ByteBuffer _bb, UnsortedSegmentProdOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public UnsortedSegmentProdOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartUnsortedSegmentProdOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.UnsortedSegmentProdOptions> EndUnsortedSegmentProdOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.UnsortedSegmentProdOptions>(o);
  }
}


static class UnsortedSegmentProdOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct UnsortedSegmentMaxOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static UnsortedSegmentMaxOptions GetRootAsUnsortedSegmentMaxOptions(ByteBuffer _bb) { return GetRootAsUnsortedSegmentMaxOptions(_bb, new UnsortedSegmentMaxOptions()); }
  public static UnsortedSegmentMaxOptions GetRootAsUnsortedSegmentMaxOptions(ByteBuffer _bb, UnsortedSegmentMaxOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public UnsortedSegmentMaxOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartUnsortedSegmentMaxOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.UnsortedSegmentMaxOptions> EndUnsortedSegmentMaxOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.UnsortedSegmentMaxOptions>(o);
  }
}


static class UnsortedSegmentMaxOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct UnsortedSegmentSumOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static UnsortedSegmentSumOptions GetRootAsUnsortedSegmentSumOptions(ByteBuffer _bb) { return GetRootAsUnsortedSegmentSumOptions(_bb, new UnsortedSegmentSumOptions()); }
  public static UnsortedSegmentSumOptions GetRootAsUnsortedSegmentSumOptions(ByteBuffer _bb, UnsortedSegmentSumOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public UnsortedSegmentSumOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartUnsortedSegmentSumOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.UnsortedSegmentSumOptions> EndUnsortedSegmentSumOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.UnsortedSegmentSumOptions>(o);
  }
}


static class UnsortedSegmentSumOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct ATan2Options : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ATan2Options GetRootAsATan2Options(ByteBuffer _bb) { return GetRootAsATan2Options(_bb, new ATan2Options()); }
  public static ATan2Options GetRootAsATan2Options(ByteBuffer _bb, ATan2Options obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ATan2Options __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartATan2Options(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ATan2Options> EndATan2Options(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.ATan2Options>(o);
  }
}


static class ATan2OptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct UnsortedSegmentMinOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static UnsortedSegmentMinOptions GetRootAsUnsortedSegmentMinOptions(ByteBuffer _bb) { return GetRootAsUnsortedSegmentMinOptions(_bb, new UnsortedSegmentMinOptions()); }
  public static UnsortedSegmentMinOptions GetRootAsUnsortedSegmentMinOptions(ByteBuffer _bb, UnsortedSegmentMinOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public UnsortedSegmentMinOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartUnsortedSegmentMinOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.UnsortedSegmentMinOptions> EndUnsortedSegmentMinOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.UnsortedSegmentMinOptions>(o);
  }
}


static class UnsortedSegmentMinOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SignOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SignOptions GetRootAsSignOptions(ByteBuffer _bb) { return GetRootAsSignOptions(_bb, new SignOptions()); }
  public static SignOptions GetRootAsSignOptions(ByteBuffer _bb, SignOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SignOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartSignOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SignOptions> EndSignOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SignOptions>(o);
  }
}


static class SignOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct BitcastOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static BitcastOptions GetRootAsBitcastOptions(ByteBuffer _bb) { return GetRootAsBitcastOptions(_bb, new BitcastOptions()); }
  public static BitcastOptions GetRootAsBitcastOptions(ByteBuffer _bb, BitcastOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BitcastOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartBitcastOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.BitcastOptions> EndBitcastOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.BitcastOptions>(o);
  }
}


static class BitcastOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct BitwiseXorOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static BitwiseXorOptions GetRootAsBitwiseXorOptions(ByteBuffer _bb) { return GetRootAsBitwiseXorOptions(_bb, new BitwiseXorOptions()); }
  public static BitwiseXorOptions GetRootAsBitwiseXorOptions(ByteBuffer _bb, BitwiseXorOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BitwiseXorOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartBitwiseXorOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.BitwiseXorOptions> EndBitwiseXorOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.BitwiseXorOptions>(o);
  }
}


static class BitwiseXorOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct RightShiftOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static RightShiftOptions GetRootAsRightShiftOptions(ByteBuffer _bb) { return GetRootAsRightShiftOptions(_bb, new RightShiftOptions()); }
  public static RightShiftOptions GetRootAsRightShiftOptions(ByteBuffer _bb, RightShiftOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RightShiftOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartRightShiftOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.RightShiftOptions> EndRightShiftOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.RightShiftOptions>(o);
  }
}


static class RightShiftOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct DilateOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static DilateOptions GetRootAsDilateOptions(ByteBuffer _bb) { return GetRootAsDilateOptions(_bb, new DilateOptions()); }
  public static DilateOptions GetRootAsDilateOptions(ByteBuffer _bb, DilateOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DilateOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartDilateOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.DilateOptions> EndDilateOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.DilateOptions>(o);
  }
}


static class DilateOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct ReduceWindowOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ReduceWindowOptions GetRootAsReduceWindowOptions(ByteBuffer _bb) { return GetRootAsReduceWindowOptions(_bb, new ReduceWindowOptions()); }
  public static ReduceWindowOptions GetRootAsReduceWindowOptions(ByteBuffer _bb, ReduceWindowOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ReduceWindowOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.ReduceWindowFunction ReduceFunction { get { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.ReduceWindowFunction)__p.bb.GetInt(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.ReduceWindowFunction.UNSUPPORTED; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ReduceWindowOptions> CreateReduceWindowOptions(FlatBufferBuilder builder,
      Unity.InferenceEngine.Editor.LiteRT.ReduceWindowFunction reduce_function = Unity.InferenceEngine.Editor.LiteRT.ReduceWindowFunction.UNSUPPORTED) {
    builder.StartTable(1);
    ReduceWindowOptions.AddReduceFunction(builder, reduce_function);
    return ReduceWindowOptions.EndReduceWindowOptions(builder);
  }

  public static void StartReduceWindowOptions(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddReduceFunction(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.ReduceWindowFunction reduceFunction) { builder.AddInt(0, (int)reduceFunction, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.ReduceWindowOptions> EndReduceWindowOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.ReduceWindowOptions>(o);
  }
}


static class ReduceWindowOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*ReduceFunction*/, 4 /*Unity.InferenceEngine.Editor.LiteRT.ReduceWindowFunction*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct OperatorCode : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static OperatorCode GetRootAsOperatorCode(ByteBuffer _bb) { return GetRootAsOperatorCode(_bb, new OperatorCode()); }
  public static OperatorCode GetRootAsOperatorCode(ByteBuffer _bb, OperatorCode obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public OperatorCode __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public sbyte DeprecatedBuiltinCode { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetSbyte(o + __p.bb_pos) : (sbyte)0; } }
  public string CustomCode { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCustomCodeBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetCustomCodeBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetCustomCodeArray() { return __p.__vector_as_array<byte>(6); }
  public int Version { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)1; } }
  public Unity.InferenceEngine.Editor.LiteRT.BuiltinOperator BuiltinCode { get { int o = __p.__offset(10); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.BuiltinOperator)__p.bb.GetInt(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.BuiltinOperator.ADD; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.OperatorCode> CreateOperatorCode(FlatBufferBuilder builder,
      sbyte deprecated_builtin_code = 0,
      StringOffset custom_codeOffset = default(StringOffset),
      int version = 1,
      Unity.InferenceEngine.Editor.LiteRT.BuiltinOperator builtin_code = Unity.InferenceEngine.Editor.LiteRT.BuiltinOperator.ADD) {
    builder.StartTable(4);
    OperatorCode.AddBuiltinCode(builder, builtin_code);
    OperatorCode.AddVersion(builder, version);
    OperatorCode.AddCustomCode(builder, custom_codeOffset);
    OperatorCode.AddDeprecatedBuiltinCode(builder, deprecated_builtin_code);
    return OperatorCode.EndOperatorCode(builder);
  }

  public static void StartOperatorCode(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddDeprecatedBuiltinCode(FlatBufferBuilder builder, sbyte deprecatedBuiltinCode) { builder.AddSbyte(0, deprecatedBuiltinCode, 0); }
  public static void AddCustomCode(FlatBufferBuilder builder, StringOffset customCodeOffset) { builder.AddOffset(1, customCodeOffset.Value, 0); }
  public static void AddVersion(FlatBufferBuilder builder, int version) { builder.AddInt(2, version, 1); }
  public static void AddBuiltinCode(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.BuiltinOperator builtinCode) { builder.AddInt(3, (int)builtinCode, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.OperatorCode> EndOperatorCode(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.OperatorCode>(o);
  }
}


static class OperatorCodeVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*DeprecatedBuiltinCode*/, 1 /*sbyte*/, 1, false)
      && verifier.VerifyString(tablePos, 6 /*CustomCode*/, false)
      && verifier.VerifyField(tablePos, 8 /*Version*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*BuiltinCode*/, 4 /*Unity.InferenceEngine.Editor.LiteRT.BuiltinOperator*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StableHLOCompositeOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StableHLOCompositeOptions GetRootAsStableHLOCompositeOptions(ByteBuffer _bb) { return GetRootAsStableHLOCompositeOptions(_bb, new StableHLOCompositeOptions()); }
  public static StableHLOCompositeOptions GetRootAsStableHLOCompositeOptions(ByteBuffer _bb, StableHLOCompositeOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StableHLOCompositeOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(4); }
  public int DecompositionSubgraphIndex { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public byte CompositeAttributes(int j) { int o = __p.__offset(8); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int CompositeAttributesLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCompositeAttributesBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetCompositeAttributesBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetCompositeAttributesArray() { return __p.__vector_as_array<byte>(8); }
  public Unity.InferenceEngine.Editor.LiteRT.CustomOptionsFormat CompositeAttributesFormat { get { int o = __p.__offset(10); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.CustomOptionsFormat)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.CustomOptionsFormat.FLEXBUFFERS; } }
  public int Version { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StableHLOCompositeOptions> CreateStableHLOCompositeOptions(FlatBufferBuilder builder,
      StringOffset nameOffset = default(StringOffset),
      int decomposition_subgraph_index = 0,
      VectorOffset composite_attributesOffset = default(VectorOffset),
      Unity.InferenceEngine.Editor.LiteRT.CustomOptionsFormat composite_attributes_format = Unity.InferenceEngine.Editor.LiteRT.CustomOptionsFormat.FLEXBUFFERS,
      int version = 0) {
    builder.StartTable(5);
    StableHLOCompositeOptions.AddVersion(builder, version);
    StableHLOCompositeOptions.AddCompositeAttributes(builder, composite_attributesOffset);
    StableHLOCompositeOptions.AddDecompositionSubgraphIndex(builder, decomposition_subgraph_index);
    StableHLOCompositeOptions.AddName(builder, nameOffset);
    StableHLOCompositeOptions.AddCompositeAttributesFormat(builder, composite_attributes_format);
    return StableHLOCompositeOptions.EndStableHLOCompositeOptions(builder);
  }

  public static void StartStableHLOCompositeOptions(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }
  public static void AddDecompositionSubgraphIndex(FlatBufferBuilder builder, int decompositionSubgraphIndex) { builder.AddInt(1, decompositionSubgraphIndex, 0); }
  public static void AddCompositeAttributes(FlatBufferBuilder builder, VectorOffset compositeAttributesOffset) { builder.AddOffset(2, compositeAttributesOffset.Value, 0); }
  public static VectorOffset CreateCompositeAttributesVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateCompositeAttributesVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCompositeAttributesVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCompositeAttributesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCompositeAttributesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddCompositeAttributesFormat(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.CustomOptionsFormat compositeAttributesFormat) { builder.AddSbyte(3, (sbyte)compositeAttributesFormat, 0); }
  public static void AddVersion(FlatBufferBuilder builder, int version) { builder.AddInt(4, version, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StableHLOCompositeOptions> EndStableHLOCompositeOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StableHLOCompositeOptions>(o);
  }
}


static class StableHLOCompositeOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Name*/, false)
      && verifier.VerifyField(tablePos, 6 /*DecompositionSubgraphIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyVectorOfData(tablePos, 8 /*CompositeAttributes*/, 1 /*byte*/, false)
      && verifier.VerifyField(tablePos, 10 /*CompositeAttributesFormat*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.CustomOptionsFormat*/, 1, false)
      && verifier.VerifyField(tablePos, 12 /*Version*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct StablehloShiftLeftOptions : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static StablehloShiftLeftOptions GetRootAsStablehloShiftLeftOptions(ByteBuffer _bb) { return GetRootAsStablehloShiftLeftOptions(_bb, new StablehloShiftLeftOptions()); }
  public static StablehloShiftLeftOptions GetRootAsStablehloShiftLeftOptions(ByteBuffer _bb, StablehloShiftLeftOptions obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StablehloShiftLeftOptions __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartStablehloShiftLeftOptions(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloShiftLeftOptions> EndStablehloShiftLeftOptions(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.StablehloShiftLeftOptions>(o);
  }
}


static class StablehloShiftLeftOptionsVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct Operator : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static Operator GetRootAsOperator(ByteBuffer _bb) { return GetRootAsOperator(_bb, new Operator()); }
  public static Operator GetRootAsOperator(ByteBuffer _bb, Operator obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Operator __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public uint OpcodeIndex { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public int Inputs(int j) { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int InputsLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetInputsBytes() { return __p.__vector_as_span<int>(6, 4); }
#else
  public ArraySegment<byte>? GetInputsBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public int[] GetInputsArray() { return __p.__vector_as_array<int>(6); }
  public int Outputs(int j) { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int OutputsLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetOutputsBytes() { return __p.__vector_as_span<int>(8, 4); }
#else
  public ArraySegment<byte>? GetOutputsBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public int[] GetOutputsArray() { return __p.__vector_as_array<int>(8); }
  public Unity.InferenceEngine.Editor.LiteRT.BuiltinOptions BuiltinOptionsType { get { int o = __p.__offset(10); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.BuiltinOptions)__p.bb.Get(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.BuiltinOptions.NONE; } }
  public TTable? BuiltinOptions<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(12); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public Unity.InferenceEngine.Editor.LiteRT.Conv2DOptions BuiltinOptionsAsConv2DOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.Conv2DOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.DepthwiseConv2DOptions BuiltinOptionsAsDepthwiseConv2DOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.DepthwiseConv2DOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.ConcatEmbeddingsOptions BuiltinOptionsAsConcatEmbeddingsOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.ConcatEmbeddingsOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.LSHProjectionOptions BuiltinOptionsAsLSHProjectionOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.LSHProjectionOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.Pool2DOptions BuiltinOptionsAsPool2DOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.Pool2DOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.SVDFOptions BuiltinOptionsAsSVDFOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.SVDFOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.RNNOptions BuiltinOptionsAsRNNOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.RNNOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.FullyConnectedOptions BuiltinOptionsAsFullyConnectedOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.FullyConnectedOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.SoftmaxOptions BuiltinOptionsAsSoftmaxOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.SoftmaxOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.ConcatenationOptions BuiltinOptionsAsConcatenationOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.ConcatenationOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.AddOptions BuiltinOptionsAsAddOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.AddOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.L2NormOptions BuiltinOptionsAsL2NormOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.L2NormOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.LocalResponseNormalizationOptions BuiltinOptionsAsLocalResponseNormalizationOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.LocalResponseNormalizationOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.LSTMOptions BuiltinOptionsAsLSTMOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.LSTMOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.ResizeBilinearOptions BuiltinOptionsAsResizeBilinearOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.ResizeBilinearOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.CallOptions BuiltinOptionsAsCallOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.CallOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.ReshapeOptions BuiltinOptionsAsReshapeOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.ReshapeOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.SkipGramOptions BuiltinOptionsAsSkipGramOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.SkipGramOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.SpaceToDepthOptions BuiltinOptionsAsSpaceToDepthOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.SpaceToDepthOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.EmbeddingLookupSparseOptions BuiltinOptionsAsEmbeddingLookupSparseOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.EmbeddingLookupSparseOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.MulOptions BuiltinOptionsAsMulOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.MulOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.PadOptions BuiltinOptionsAsPadOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.PadOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.GatherOptions BuiltinOptionsAsGatherOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.GatherOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.BatchToSpaceNDOptions BuiltinOptionsAsBatchToSpaceNDOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.BatchToSpaceNDOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.SpaceToBatchNDOptions BuiltinOptionsAsSpaceToBatchNDOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.SpaceToBatchNDOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.TransposeOptions BuiltinOptionsAsTransposeOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.TransposeOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.ReducerOptions BuiltinOptionsAsReducerOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.ReducerOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.SubOptions BuiltinOptionsAsSubOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.SubOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.DivOptions BuiltinOptionsAsDivOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.DivOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.SqueezeOptions BuiltinOptionsAsSqueezeOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.SqueezeOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.SequenceRNNOptions BuiltinOptionsAsSequenceRNNOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.SequenceRNNOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StridedSliceOptions BuiltinOptionsAsStridedSliceOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.StridedSliceOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.ExpOptions BuiltinOptionsAsExpOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.ExpOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.TopKV2Options BuiltinOptionsAsTopKV2Options() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.TopKV2Options>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.SplitOptions BuiltinOptionsAsSplitOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.SplitOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.LogSoftmaxOptions BuiltinOptionsAsLogSoftmaxOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.LogSoftmaxOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.CastOptions BuiltinOptionsAsCastOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.CastOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.DequantizeOptions BuiltinOptionsAsDequantizeOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.DequantizeOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.MaximumMinimumOptions BuiltinOptionsAsMaximumMinimumOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.MaximumMinimumOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.ArgMaxOptions BuiltinOptionsAsArgMaxOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.ArgMaxOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.LessOptions BuiltinOptionsAsLessOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.LessOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.NegOptions BuiltinOptionsAsNegOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.NegOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.PadV2Options BuiltinOptionsAsPadV2Options() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.PadV2Options>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.GreaterOptions BuiltinOptionsAsGreaterOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.GreaterOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.GreaterEqualOptions BuiltinOptionsAsGreaterEqualOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.GreaterEqualOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.LessEqualOptions BuiltinOptionsAsLessEqualOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.LessEqualOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.SelectOptions BuiltinOptionsAsSelectOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.SelectOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.SliceOptions BuiltinOptionsAsSliceOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.SliceOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.TransposeConvOptions BuiltinOptionsAsTransposeConvOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.TransposeConvOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.SparseToDenseOptions BuiltinOptionsAsSparseToDenseOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.SparseToDenseOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.TileOptions BuiltinOptionsAsTileOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.TileOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.ExpandDimsOptions BuiltinOptionsAsExpandDimsOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.ExpandDimsOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.EqualOptions BuiltinOptionsAsEqualOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.EqualOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.NotEqualOptions BuiltinOptionsAsNotEqualOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.NotEqualOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.ShapeOptions BuiltinOptionsAsShapeOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.ShapeOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.PowOptions BuiltinOptionsAsPowOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.PowOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.ArgMinOptions BuiltinOptionsAsArgMinOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.ArgMinOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.FakeQuantOptions BuiltinOptionsAsFakeQuantOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.FakeQuantOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.PackOptions BuiltinOptionsAsPackOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.PackOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.LogicalOrOptions BuiltinOptionsAsLogicalOrOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.LogicalOrOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.OneHotOptions BuiltinOptionsAsOneHotOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.OneHotOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.LogicalAndOptions BuiltinOptionsAsLogicalAndOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.LogicalAndOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.LogicalNotOptions BuiltinOptionsAsLogicalNotOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.LogicalNotOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.UnpackOptions BuiltinOptionsAsUnpackOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.UnpackOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.FloorDivOptions BuiltinOptionsAsFloorDivOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.FloorDivOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.SquareOptions BuiltinOptionsAsSquareOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.SquareOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.ZerosLikeOptions BuiltinOptionsAsZerosLikeOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.ZerosLikeOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.FillOptions BuiltinOptionsAsFillOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.FillOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.BidirectionalSequenceLSTMOptions BuiltinOptionsAsBidirectionalSequenceLSTMOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.BidirectionalSequenceLSTMOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.BidirectionalSequenceRNNOptions BuiltinOptionsAsBidirectionalSequenceRNNOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.BidirectionalSequenceRNNOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.UnidirectionalSequenceLSTMOptions BuiltinOptionsAsUnidirectionalSequenceLSTMOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.UnidirectionalSequenceLSTMOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.FloorModOptions BuiltinOptionsAsFloorModOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.FloorModOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.RangeOptions BuiltinOptionsAsRangeOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.RangeOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.ResizeNearestNeighborOptions BuiltinOptionsAsResizeNearestNeighborOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.ResizeNearestNeighborOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.LeakyReluOptions BuiltinOptionsAsLeakyReluOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.LeakyReluOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.SquaredDifferenceOptions BuiltinOptionsAsSquaredDifferenceOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.SquaredDifferenceOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.MirrorPadOptions BuiltinOptionsAsMirrorPadOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.MirrorPadOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.AbsOptions BuiltinOptionsAsAbsOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.AbsOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.SplitVOptions BuiltinOptionsAsSplitVOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.SplitVOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.UniqueOptions BuiltinOptionsAsUniqueOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.UniqueOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.ReverseV2Options BuiltinOptionsAsReverseV2Options() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.ReverseV2Options>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.AddNOptions BuiltinOptionsAsAddNOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.AddNOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.GatherNdOptions BuiltinOptionsAsGatherNdOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.GatherNdOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.CosOptions BuiltinOptionsAsCosOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.CosOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.WhereOptions BuiltinOptionsAsWhereOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.WhereOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.RankOptions BuiltinOptionsAsRankOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.RankOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.ReverseSequenceOptions BuiltinOptionsAsReverseSequenceOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.ReverseSequenceOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.MatrixDiagOptions BuiltinOptionsAsMatrixDiagOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.MatrixDiagOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.QuantizeOptions BuiltinOptionsAsQuantizeOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.QuantizeOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.MatrixSetDiagOptions BuiltinOptionsAsMatrixSetDiagOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.MatrixSetDiagOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.HardSwishOptions BuiltinOptionsAsHardSwishOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.HardSwishOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.IfOptions BuiltinOptionsAsIfOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.IfOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.WhileOptions BuiltinOptionsAsWhileOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.WhileOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.DepthToSpaceOptions BuiltinOptionsAsDepthToSpaceOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.DepthToSpaceOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.NonMaxSuppressionV4Options BuiltinOptionsAsNonMaxSuppressionV4Options() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.NonMaxSuppressionV4Options>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.NonMaxSuppressionV5Options BuiltinOptionsAsNonMaxSuppressionV5Options() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.NonMaxSuppressionV5Options>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.ScatterNdOptions BuiltinOptionsAsScatterNdOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.ScatterNdOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.SelectV2Options BuiltinOptionsAsSelectV2Options() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.SelectV2Options>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.DensifyOptions BuiltinOptionsAsDensifyOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.DensifyOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.SegmentSumOptions BuiltinOptionsAsSegmentSumOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.SegmentSumOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.BatchMatMulOptions BuiltinOptionsAsBatchMatMulOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.BatchMatMulOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.CumsumOptions BuiltinOptionsAsCumsumOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.CumsumOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.CallOnceOptions BuiltinOptionsAsCallOnceOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.CallOnceOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.BroadcastToOptions BuiltinOptionsAsBroadcastToOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.BroadcastToOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.Rfft2dOptions BuiltinOptionsAsRfft2dOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.Rfft2dOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.Conv3DOptions BuiltinOptionsAsConv3DOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.Conv3DOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.HashtableOptions BuiltinOptionsAsHashtableOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.HashtableOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.HashtableFindOptions BuiltinOptionsAsHashtableFindOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.HashtableFindOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.HashtableImportOptions BuiltinOptionsAsHashtableImportOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.HashtableImportOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.HashtableSizeOptions BuiltinOptionsAsHashtableSizeOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.HashtableSizeOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.VarHandleOptions BuiltinOptionsAsVarHandleOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.VarHandleOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.ReadVariableOptions BuiltinOptionsAsReadVariableOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.ReadVariableOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.AssignVariableOptions BuiltinOptionsAsAssignVariableOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.AssignVariableOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.RandomOptions BuiltinOptionsAsRandomOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.RandomOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.BucketizeOptions BuiltinOptionsAsBucketizeOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.BucketizeOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.GeluOptions BuiltinOptionsAsGeluOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.GeluOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.DynamicUpdateSliceOptions BuiltinOptionsAsDynamicUpdateSliceOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.DynamicUpdateSliceOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.UnsortedSegmentProdOptions BuiltinOptionsAsUnsortedSegmentProdOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.UnsortedSegmentProdOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.UnsortedSegmentMaxOptions BuiltinOptionsAsUnsortedSegmentMaxOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.UnsortedSegmentMaxOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.UnsortedSegmentMinOptions BuiltinOptionsAsUnsortedSegmentMinOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.UnsortedSegmentMinOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.UnsortedSegmentSumOptions BuiltinOptionsAsUnsortedSegmentSumOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.UnsortedSegmentSumOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.ATan2Options BuiltinOptionsAsATan2Options() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.ATan2Options>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.SignOptions BuiltinOptionsAsSignOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.SignOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.BitcastOptions BuiltinOptionsAsBitcastOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.BitcastOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.BitwiseXorOptions BuiltinOptionsAsBitwiseXorOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.BitwiseXorOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.RightShiftOptions BuiltinOptionsAsRightShiftOptions() { return BuiltinOptions<Unity.InferenceEngine.Editor.LiteRT.RightShiftOptions>().Value; }
  public byte CustomOptions(int j) { int o = __p.__offset(14); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int CustomOptionsLength { get { int o = __p.__offset(14); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCustomOptionsBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetCustomOptionsBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetCustomOptionsArray() { return __p.__vector_as_array<byte>(14); }
  public Unity.InferenceEngine.Editor.LiteRT.CustomOptionsFormat CustomOptionsFormat { get { int o = __p.__offset(16); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.CustomOptionsFormat)__p.bb.GetSbyte(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.CustomOptionsFormat.FLEXBUFFERS; } }
  public bool MutatingVariableInputs(int j) { int o = __p.__offset(18); return o != 0 ? 0!=__p.bb.Get(__p.__vector(o) + j * 1) : false; }
  public int MutatingVariableInputsLength { get { int o = __p.__offset(18); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<bool> GetMutatingVariableInputsBytes() { return __p.__vector_as_span<bool>(18, 1); }
#else
  public ArraySegment<byte>? GetMutatingVariableInputsBytes() { return __p.__vector_as_arraysegment(18); }
#endif
  public bool[] GetMutatingVariableInputsArray() { return __p.__vector_as_array<bool>(18); }
  public int Intermediates(int j) { int o = __p.__offset(20); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int IntermediatesLength { get { int o = __p.__offset(20); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetIntermediatesBytes() { return __p.__vector_as_span<int>(20, 4); }
#else
  public ArraySegment<byte>? GetIntermediatesBytes() { return __p.__vector_as_arraysegment(20); }
#endif
  public int[] GetIntermediatesArray() { return __p.__vector_as_array<int>(20); }
  public ulong LargeCustomOptionsOffset { get { int o = __p.__offset(22); return o != 0 ? __p.bb.GetUlong(o + __p.bb_pos) : (ulong)0; } }
  public ulong LargeCustomOptionsSize { get { int o = __p.__offset(24); return o != 0 ? __p.bb.GetUlong(o + __p.bb_pos) : (ulong)0; } }
  public Unity.InferenceEngine.Editor.LiteRT.BuiltinOptions2 BuiltinOptions2Type { get { int o = __p.__offset(26); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.BuiltinOptions2)__p.bb.Get(o + __p.bb_pos) : Unity.InferenceEngine.Editor.LiteRT.BuiltinOptions2.NONE; } }
  public TTable? BuiltinOptions2<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(28); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloConcatenateOptions BuiltinOptions2AsStablehloConcatenateOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloConcatenateOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloBroadcastInDimOptions BuiltinOptions2AsStablehloBroadcastInDimOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloBroadcastInDimOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloSliceOptions BuiltinOptions2AsStablehloSliceOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloSliceOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloConvolutionOptions BuiltinOptions2AsStablehloConvolutionOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloConvolutionOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloCustomCallOptions BuiltinOptions2AsStablehloCustomCallOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloCustomCallOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloReduceOptions BuiltinOptions2AsStablehloReduceOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloReduceOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloScatterOptions BuiltinOptions2AsStablehloScatterOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloScatterOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloCompareOptions BuiltinOptions2AsStablehloCompareOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloCompareOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloDynamicSliceOptions BuiltinOptions2AsStablehloDynamicSliceOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloDynamicSliceOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloPadOptions BuiltinOptions2AsStablehloPadOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloPadOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloIotaOptions BuiltinOptions2AsStablehloIotaOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloIotaOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloDotGeneralOptions BuiltinOptions2AsStablehloDotGeneralOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloDotGeneralOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloReduceWindowOptions BuiltinOptions2AsStablehloReduceWindowOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloReduceWindowOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloSortOptions BuiltinOptions2AsStablehloSortOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloSortOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloWhileOptions BuiltinOptions2AsStablehloWhileOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloWhileOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloGatherOptions BuiltinOptions2AsStablehloGatherOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloGatherOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloTransposeOptions BuiltinOptions2AsStablehloTransposeOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloTransposeOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.DilateOptions BuiltinOptions2AsDilateOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.DilateOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloRngBitGeneratorOptions BuiltinOptions2AsStablehloRngBitGeneratorOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloRngBitGeneratorOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.ReduceWindowOptions BuiltinOptions2AsReduceWindowOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.ReduceWindowOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StableHLOCompositeOptions BuiltinOptions2AsStableHLOCompositeOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StableHLOCompositeOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloShiftLeftOptions BuiltinOptions2AsStablehloShiftLeftOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloShiftLeftOptions>().Value; }
  public Unity.InferenceEngine.Editor.LiteRT.StablehloCaseOptions BuiltinOptions2AsStablehloCaseOptions() { return BuiltinOptions2<Unity.InferenceEngine.Editor.LiteRT.StablehloCaseOptions>().Value; }
  public int DebugMetadataIndex { get { int o = __p.__offset(30); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)-1; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Operator> CreateOperator(FlatBufferBuilder builder,
      uint opcode_index = 0,
      VectorOffset inputsOffset = default(VectorOffset),
      VectorOffset outputsOffset = default(VectorOffset),
      Unity.InferenceEngine.Editor.LiteRT.BuiltinOptions builtin_options_type = Unity.InferenceEngine.Editor.LiteRT.BuiltinOptions.NONE,
      int builtin_optionsOffset = 0,
      VectorOffset custom_optionsOffset = default(VectorOffset),
      Unity.InferenceEngine.Editor.LiteRT.CustomOptionsFormat custom_options_format = Unity.InferenceEngine.Editor.LiteRT.CustomOptionsFormat.FLEXBUFFERS,
      VectorOffset mutating_variable_inputsOffset = default(VectorOffset),
      VectorOffset intermediatesOffset = default(VectorOffset),
      ulong large_custom_options_offset = 0,
      ulong large_custom_options_size = 0,
      Unity.InferenceEngine.Editor.LiteRT.BuiltinOptions2 builtin_options_2_type = Unity.InferenceEngine.Editor.LiteRT.BuiltinOptions2.NONE,
      int builtin_options_2Offset = 0,
      int debug_metadata_index = -1) {
    builder.StartTable(14);
    Operator.AddLargeCustomOptionsSize(builder, large_custom_options_size);
    Operator.AddLargeCustomOptionsOffset(builder, large_custom_options_offset);
    Operator.AddDebugMetadataIndex(builder, debug_metadata_index);
    Operator.AddBuiltinOptions2(builder, builtin_options_2Offset);
    Operator.AddIntermediates(builder, intermediatesOffset);
    Operator.AddMutatingVariableInputs(builder, mutating_variable_inputsOffset);
    Operator.AddCustomOptions(builder, custom_optionsOffset);
    Operator.AddBuiltinOptions(builder, builtin_optionsOffset);
    Operator.AddOutputs(builder, outputsOffset);
    Operator.AddInputs(builder, inputsOffset);
    Operator.AddOpcodeIndex(builder, opcode_index);
    Operator.AddBuiltinOptions2Type(builder, builtin_options_2_type);
    Operator.AddCustomOptionsFormat(builder, custom_options_format);
    Operator.AddBuiltinOptionsType(builder, builtin_options_type);
    return Operator.EndOperator(builder);
  }

  public static void StartOperator(FlatBufferBuilder builder) { builder.StartTable(14); }
  public static void AddOpcodeIndex(FlatBufferBuilder builder, uint opcodeIndex) { builder.AddUint(0, opcodeIndex, 0); }
  public static void AddInputs(FlatBufferBuilder builder, VectorOffset inputsOffset) { builder.AddOffset(1, inputsOffset.Value, 0); }
  public static VectorOffset CreateInputsVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateInputsVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateInputsVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateInputsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartInputsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddOutputs(FlatBufferBuilder builder, VectorOffset outputsOffset) { builder.AddOffset(2, outputsOffset.Value, 0); }
  public static VectorOffset CreateOutputsVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateOutputsVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateOutputsVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateOutputsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartOutputsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddBuiltinOptionsType(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.BuiltinOptions builtinOptionsType) { builder.AddByte(3, (byte)builtinOptionsType, 0); }
  public static void AddBuiltinOptions(FlatBufferBuilder builder, int builtinOptionsOffset) { builder.AddOffset(4, builtinOptionsOffset, 0); }
  public static void AddCustomOptions(FlatBufferBuilder builder, VectorOffset customOptionsOffset) { builder.AddOffset(5, customOptionsOffset.Value, 0); }
  public static VectorOffset CreateCustomOptionsVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateCustomOptionsVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCustomOptionsVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCustomOptionsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCustomOptionsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddCustomOptionsFormat(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.CustomOptionsFormat customOptionsFormat) { builder.AddSbyte(6, (sbyte)customOptionsFormat, 0); }
  public static void AddMutatingVariableInputs(FlatBufferBuilder builder, VectorOffset mutatingVariableInputsOffset) { builder.AddOffset(7, mutatingVariableInputsOffset.Value, 0); }
  public static VectorOffset CreateMutatingVariableInputsVector(FlatBufferBuilder builder, bool[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddBool(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateMutatingVariableInputsVectorBlock(FlatBufferBuilder builder, bool[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMutatingVariableInputsVectorBlock(FlatBufferBuilder builder, ArraySegment<bool> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMutatingVariableInputsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<bool>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartMutatingVariableInputsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddIntermediates(FlatBufferBuilder builder, VectorOffset intermediatesOffset) { builder.AddOffset(8, intermediatesOffset.Value, 0); }
  public static VectorOffset CreateIntermediatesVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateIntermediatesVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateIntermediatesVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateIntermediatesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartIntermediatesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddLargeCustomOptionsOffset(FlatBufferBuilder builder, ulong largeCustomOptionsOffset) { builder.AddUlong(9, largeCustomOptionsOffset, 0); }
  public static void AddLargeCustomOptionsSize(FlatBufferBuilder builder, ulong largeCustomOptionsSize) { builder.AddUlong(10, largeCustomOptionsSize, 0); }
  public static void AddBuiltinOptions2Type(FlatBufferBuilder builder, Unity.InferenceEngine.Editor.LiteRT.BuiltinOptions2 builtinOptions2Type) { builder.AddByte(11, (byte)builtinOptions2Type, 0); }
  public static void AddBuiltinOptions2(FlatBufferBuilder builder, int builtinOptions2Offset) { builder.AddOffset(12, builtinOptions2Offset, 0); }
  public static void AddDebugMetadataIndex(FlatBufferBuilder builder, int debugMetadataIndex) { builder.AddInt(13, debugMetadataIndex, -1); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Operator> EndOperator(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.Operator>(o);
  }
}


static class OperatorVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*OpcodeIndex*/, 4 /*uint*/, 4, false)
      && verifier.VerifyVectorOfData(tablePos, 6 /*Inputs*/, 4 /*int*/, false)
      && verifier.VerifyVectorOfData(tablePos, 8 /*Outputs*/, 4 /*int*/, false)
      && verifier.VerifyField(tablePos, 10 /*BuiltinOptionsType*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.BuiltinOptions*/, 1, false)
      // && verifier.VerifyUnion(tablePos, 10, 12 /*BuiltinOptions*/, Unity.InferenceEngine.Editor.LiteRT.BuiltinOptionsVerify.Verify, false)
      && verifier.VerifyVectorOfData(tablePos, 14 /*CustomOptions*/, 1 /*byte*/, false)
      && verifier.VerifyField(tablePos, 16 /*CustomOptionsFormat*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.CustomOptionsFormat*/, 1, false)
      && verifier.VerifyVectorOfData(tablePos, 18 /*MutatingVariableInputs*/, 1 /*bool*/, false)
      && verifier.VerifyVectorOfData(tablePos, 20 /*Intermediates*/, 4 /*int*/, false)
      && verifier.VerifyField(tablePos, 22 /*LargeCustomOptionsOffset*/, 8 /*ulong*/, 8, false)
      && verifier.VerifyField(tablePos, 24 /*LargeCustomOptionsSize*/, 8 /*ulong*/, 8, false)
      && verifier.VerifyField(tablePos, 26 /*BuiltinOptions2Type*/, 1 /*Unity.InferenceEngine.Editor.LiteRT.BuiltinOptions2*/, 1, false)
      // && verifier.VerifyUnion(tablePos, 26, 28 /*BuiltinOptions2*/, Unity.InferenceEngine.Editor.LiteRT.BuiltinOptions2Verify.Verify, false)
      && verifier.VerifyField(tablePos, 30 /*DebugMetadataIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SubGraph : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SubGraph GetRootAsSubGraph(ByteBuffer _bb) { return GetRootAsSubGraph(_bb, new SubGraph()); }
  public static SubGraph GetRootAsSubGraph(ByteBuffer _bb, SubGraph obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SubGraph __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.Tensor? Tensors(int j) { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.Tensor?)(new Unity.InferenceEngine.Editor.LiteRT.Tensor()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int TensorsLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
  public int Inputs(int j) { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int InputsLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetInputsBytes() { return __p.__vector_as_span<int>(6, 4); }
#else
  public ArraySegment<byte>? GetInputsBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public int[] GetInputsArray() { return __p.__vector_as_array<int>(6); }
  public int Outputs(int j) { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int OutputsLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetOutputsBytes() { return __p.__vector_as_span<int>(8, 4); }
#else
  public ArraySegment<byte>? GetOutputsBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public int[] GetOutputsArray() { return __p.__vector_as_array<int>(8); }
  public Unity.InferenceEngine.Editor.LiteRT.Operator? Operators(int j) { int o = __p.__offset(10); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.Operator?)(new Unity.InferenceEngine.Editor.LiteRT.Operator()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int OperatorsLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }
  public string Name { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(12); }
  public int DebugMetadataIndex { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)-1; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SubGraph> CreateSubGraph(FlatBufferBuilder builder,
      VectorOffset tensorsOffset = default(VectorOffset),
      VectorOffset inputsOffset = default(VectorOffset),
      VectorOffset outputsOffset = default(VectorOffset),
      VectorOffset operatorsOffset = default(VectorOffset),
      StringOffset nameOffset = default(StringOffset),
      int debug_metadata_index = -1) {
    builder.StartTable(6);
    SubGraph.AddDebugMetadataIndex(builder, debug_metadata_index);
    SubGraph.AddName(builder, nameOffset);
    SubGraph.AddOperators(builder, operatorsOffset);
    SubGraph.AddOutputs(builder, outputsOffset);
    SubGraph.AddInputs(builder, inputsOffset);
    SubGraph.AddTensors(builder, tensorsOffset);
    return SubGraph.EndSubGraph(builder);
  }

  public static void StartSubGraph(FlatBufferBuilder builder) { builder.StartTable(6); }
  public static void AddTensors(FlatBufferBuilder builder, VectorOffset tensorsOffset) { builder.AddOffset(0, tensorsOffset.Value, 0); }
  public static VectorOffset CreateTensorsVector(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.Tensor>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateTensorsVectorBlock(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.Tensor>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTensorsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Unity.InferenceEngine.Editor.LiteRT.Tensor>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTensorsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Unity.InferenceEngine.Editor.LiteRT.Tensor>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartTensorsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddInputs(FlatBufferBuilder builder, VectorOffset inputsOffset) { builder.AddOffset(1, inputsOffset.Value, 0); }
  public static VectorOffset CreateInputsVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateInputsVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateInputsVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateInputsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartInputsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddOutputs(FlatBufferBuilder builder, VectorOffset outputsOffset) { builder.AddOffset(2, outputsOffset.Value, 0); }
  public static VectorOffset CreateOutputsVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateOutputsVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateOutputsVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateOutputsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartOutputsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddOperators(FlatBufferBuilder builder, VectorOffset operatorsOffset) { builder.AddOffset(3, operatorsOffset.Value, 0); }
  public static VectorOffset CreateOperatorsVector(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.Operator>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateOperatorsVectorBlock(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.Operator>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateOperatorsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Unity.InferenceEngine.Editor.LiteRT.Operator>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateOperatorsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Unity.InferenceEngine.Editor.LiteRT.Operator>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartOperatorsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(4, nameOffset.Value, 0); }
  public static void AddDebugMetadataIndex(FlatBufferBuilder builder, int debugMetadataIndex) { builder.AddInt(5, debugMetadataIndex, -1); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SubGraph> EndSubGraph(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SubGraph>(o);
  }
}


static class SubGraphVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfTables(tablePos, 4 /*Tensors*/, Unity.InferenceEngine.Editor.LiteRT.TensorVerify.Verify, false)
      && verifier.VerifyVectorOfData(tablePos, 6 /*Inputs*/, 4 /*int*/, false)
      && verifier.VerifyVectorOfData(tablePos, 8 /*Outputs*/, 4 /*int*/, false)
      && verifier.VerifyVectorOfTables(tablePos, 10 /*Operators*/, Unity.InferenceEngine.Editor.LiteRT.OperatorVerify.Verify, false)
      && verifier.VerifyString(tablePos, 12 /*Name*/, false)
      && verifier.VerifyField(tablePos, 14 /*DebugMetadataIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct Buffer : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static Buffer GetRootAsBuffer(ByteBuffer _bb) { return GetRootAsBuffer(_bb, new Buffer()); }
  public static Buffer GetRootAsBuffer(ByteBuffer _bb, Buffer obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Buffer __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public byte Data(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int DataLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDataBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetDataBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetDataArray() { return __p.__vector_as_array<byte>(4); }
  public ulong Offset { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetUlong(o + __p.bb_pos) : (ulong)0; } }
  public ulong Size { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetUlong(o + __p.bb_pos) : (ulong)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Buffer> CreateBuffer(FlatBufferBuilder builder,
      VectorOffset dataOffset = default(VectorOffset),
      ulong offset = 0,
      ulong size = 0) {
    builder.StartTable(3);
    Buffer.AddSize(builder, size);
    Buffer.AddOffset(builder, offset);
    Buffer.AddData(builder, dataOffset);
    return Buffer.EndBuffer(builder);
  }

  public static void StartBuffer(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddData(FlatBufferBuilder builder, VectorOffset dataOffset) { builder.AddOffset(0, dataOffset.Value, 0); }
  public static VectorOffset CreateDataVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateDataVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateDataVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateDataVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartDataVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddOffset(FlatBufferBuilder builder, ulong offset) { builder.AddUlong(1, offset, 0); }
  public static void AddSize(FlatBufferBuilder builder, ulong size) { builder.AddUlong(2, size, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Buffer> EndBuffer(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.Buffer>(o);
  }
}


static class BufferVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*Data*/, 1 /*byte*/, false)
      && verifier.VerifyField(tablePos, 6 /*Offset*/, 8 /*ulong*/, 8, false)
      && verifier.VerifyField(tablePos, 8 /*Size*/, 8 /*ulong*/, 8, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct Metadata : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static Metadata GetRootAsMetadata(ByteBuffer _bb) { return GetRootAsMetadata(_bb, new Metadata()); }
  public static Metadata GetRootAsMetadata(ByteBuffer _bb, Metadata obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Metadata __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(4); }
  public uint Buffer { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Metadata> CreateMetadata(FlatBufferBuilder builder,
      StringOffset nameOffset = default(StringOffset),
      uint buffer = 0) {
    builder.StartTable(2);
    Metadata.AddBuffer(builder, buffer);
    Metadata.AddName(builder, nameOffset);
    return Metadata.EndMetadata(builder);
  }

  public static void StartMetadata(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }
  public static void AddBuffer(FlatBufferBuilder builder, uint buffer) { builder.AddUint(1, buffer, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Metadata> EndMetadata(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.Metadata>(o);
  }
}


static class MetadataVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Name*/, false)
      && verifier.VerifyField(tablePos, 6 /*Buffer*/, 4 /*uint*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct TensorMap : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static TensorMap GetRootAsTensorMap(ByteBuffer _bb) { return GetRootAsTensorMap(_bb, new TensorMap()); }
  public static TensorMap GetRootAsTensorMap(ByteBuffer _bb, TensorMap obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TensorMap __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(4); }
  public uint TensorIndex { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.TensorMap> CreateTensorMap(FlatBufferBuilder builder,
      StringOffset nameOffset = default(StringOffset),
      uint tensor_index = 0) {
    builder.StartTable(2);
    TensorMap.AddTensorIndex(builder, tensor_index);
    TensorMap.AddName(builder, nameOffset);
    return TensorMap.EndTensorMap(builder);
  }

  public static void StartTensorMap(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }
  public static void AddTensorIndex(FlatBufferBuilder builder, uint tensorIndex) { builder.AddUint(1, tensorIndex, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.TensorMap> EndTensorMap(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.TensorMap>(o);
  }
}


static class TensorMapVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Name*/, false)
      && verifier.VerifyField(tablePos, 6 /*TensorIndex*/, 4 /*uint*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct SignatureDef : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SignatureDef GetRootAsSignatureDef(ByteBuffer _bb) { return GetRootAsSignatureDef(_bb, new SignatureDef()); }
  public static SignatureDef GetRootAsSignatureDef(ByteBuffer _bb, SignatureDef obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SignatureDef __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Unity.InferenceEngine.Editor.LiteRT.TensorMap? Inputs(int j) { int o = __p.__offset(4); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.TensorMap?)(new Unity.InferenceEngine.Editor.LiteRT.TensorMap()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int InputsLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Unity.InferenceEngine.Editor.LiteRT.TensorMap? Outputs(int j) { int o = __p.__offset(6); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.TensorMap?)(new Unity.InferenceEngine.Editor.LiteRT.TensorMap()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int OutputsLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
  public string SignatureKey { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSignatureKeyBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetSignatureKeyBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetSignatureKeyArray() { return __p.__vector_as_array<byte>(8); }
  public uint SubgraphIndex { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SignatureDef> CreateSignatureDef(FlatBufferBuilder builder,
      VectorOffset inputsOffset = default(VectorOffset),
      VectorOffset outputsOffset = default(VectorOffset),
      StringOffset signature_keyOffset = default(StringOffset),
      uint subgraph_index = 0) {
    builder.StartTable(5);
    SignatureDef.AddSubgraphIndex(builder, subgraph_index);
    SignatureDef.AddSignatureKey(builder, signature_keyOffset);
    SignatureDef.AddOutputs(builder, outputsOffset);
    SignatureDef.AddInputs(builder, inputsOffset);
    return SignatureDef.EndSignatureDef(builder);
  }

  public static void StartSignatureDef(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddInputs(FlatBufferBuilder builder, VectorOffset inputsOffset) { builder.AddOffset(0, inputsOffset.Value, 0); }
  public static VectorOffset CreateInputsVector(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.TensorMap>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateInputsVectorBlock(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.TensorMap>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateInputsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Unity.InferenceEngine.Editor.LiteRT.TensorMap>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateInputsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Unity.InferenceEngine.Editor.LiteRT.TensorMap>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartInputsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddOutputs(FlatBufferBuilder builder, VectorOffset outputsOffset) { builder.AddOffset(1, outputsOffset.Value, 0); }
  public static VectorOffset CreateOutputsVector(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.TensorMap>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateOutputsVectorBlock(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.TensorMap>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateOutputsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Unity.InferenceEngine.Editor.LiteRT.TensorMap>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateOutputsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Unity.InferenceEngine.Editor.LiteRT.TensorMap>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartOutputsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSignatureKey(FlatBufferBuilder builder, StringOffset signatureKeyOffset) { builder.AddOffset(2, signatureKeyOffset.Value, 0); }
  public static void AddSubgraphIndex(FlatBufferBuilder builder, uint subgraphIndex) { builder.AddUint(4, subgraphIndex, 0); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.SignatureDef> EndSignatureDef(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.SignatureDef>(o);
  }
}


static class SignatureDefVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfTables(tablePos, 4 /*Inputs*/, Unity.InferenceEngine.Editor.LiteRT.TensorMapVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 6 /*Outputs*/, Unity.InferenceEngine.Editor.LiteRT.TensorMapVerify.Verify, false)
      && verifier.VerifyString(tablePos, 8 /*SignatureKey*/, false)
      && verifier.VerifyField(tablePos, 12 /*SubgraphIndex*/, 4 /*uint*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
struct Model : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static Model GetRootAsModel(ByteBuffer _bb) { return GetRootAsModel(_bb, new Model()); }
  public static Model GetRootAsModel(ByteBuffer _bb, Model obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool ModelBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "TFL3"); }
  public static bool VerifyModel(ByteBuffer _bb) {Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier = new Unity.InferenceEngine.Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("TFL3", false, ModelVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Model __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public uint Version { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public Unity.InferenceEngine.Editor.LiteRT.OperatorCode? OperatorCodes(int j) { int o = __p.__offset(6); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.OperatorCode?)(new Unity.InferenceEngine.Editor.LiteRT.OperatorCode()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int OperatorCodesLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Unity.InferenceEngine.Editor.LiteRT.SubGraph? Subgraphs(int j) { int o = __p.__offset(8); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.SubGraph?)(new Unity.InferenceEngine.Editor.LiteRT.SubGraph()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int SubgraphsLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
  public string Description { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDescriptionBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetDescriptionBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetDescriptionArray() { return __p.__vector_as_array<byte>(10); }
  public Unity.InferenceEngine.Editor.LiteRT.Buffer? Buffers(int j) { int o = __p.__offset(12); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.Buffer?)(new Unity.InferenceEngine.Editor.LiteRT.Buffer()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int BuffersLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
  public int MetadataBuffer(int j) { int o = __p.__offset(14); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int MetadataBufferLength { get { int o = __p.__offset(14); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetMetadataBufferBytes() { return __p.__vector_as_span<int>(14, 4); }
#else
  public ArraySegment<byte>? GetMetadataBufferBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public int[] GetMetadataBufferArray() { return __p.__vector_as_array<int>(14); }
  public Unity.InferenceEngine.Editor.LiteRT.Metadata? Metadata(int j) { int o = __p.__offset(16); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.Metadata?)(new Unity.InferenceEngine.Editor.LiteRT.Metadata()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int MetadataLength { get { int o = __p.__offset(16); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Unity.InferenceEngine.Editor.LiteRT.SignatureDef? SignatureDefs(int j) { int o = __p.__offset(18); return o != 0 ? (Unity.InferenceEngine.Editor.LiteRT.SignatureDef?)(new Unity.InferenceEngine.Editor.LiteRT.SignatureDef()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int SignatureDefsLength { get { int o = __p.__offset(18); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Model> CreateModel(FlatBufferBuilder builder,
      uint version = 0,
      VectorOffset operator_codesOffset = default(VectorOffset),
      VectorOffset subgraphsOffset = default(VectorOffset),
      StringOffset descriptionOffset = default(StringOffset),
      VectorOffset buffersOffset = default(VectorOffset),
      VectorOffset metadata_bufferOffset = default(VectorOffset),
      VectorOffset metadataOffset = default(VectorOffset),
      VectorOffset signature_defsOffset = default(VectorOffset)) {
    builder.StartTable(8);
    Model.AddSignatureDefs(builder, signature_defsOffset);
    Model.AddMetadata(builder, metadataOffset);
    Model.AddMetadataBuffer(builder, metadata_bufferOffset);
    Model.AddBuffers(builder, buffersOffset);
    Model.AddDescription(builder, descriptionOffset);
    Model.AddSubgraphs(builder, subgraphsOffset);
    Model.AddOperatorCodes(builder, operator_codesOffset);
    Model.AddVersion(builder, version);
    return Model.EndModel(builder);
  }

  public static void StartModel(FlatBufferBuilder builder) { builder.StartTable(8); }
  public static void AddVersion(FlatBufferBuilder builder, uint version) { builder.AddUint(0, version, 0); }
  public static void AddOperatorCodes(FlatBufferBuilder builder, VectorOffset operatorCodesOffset) { builder.AddOffset(1, operatorCodesOffset.Value, 0); }
  public static VectorOffset CreateOperatorCodesVector(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.OperatorCode>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateOperatorCodesVectorBlock(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.OperatorCode>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateOperatorCodesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Unity.InferenceEngine.Editor.LiteRT.OperatorCode>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateOperatorCodesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Unity.InferenceEngine.Editor.LiteRT.OperatorCode>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartOperatorCodesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSubgraphs(FlatBufferBuilder builder, VectorOffset subgraphsOffset) { builder.AddOffset(2, subgraphsOffset.Value, 0); }
  public static VectorOffset CreateSubgraphsVector(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.SubGraph>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSubgraphsVectorBlock(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.SubGraph>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSubgraphsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Unity.InferenceEngine.Editor.LiteRT.SubGraph>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSubgraphsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Unity.InferenceEngine.Editor.LiteRT.SubGraph>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSubgraphsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddDescription(FlatBufferBuilder builder, StringOffset descriptionOffset) { builder.AddOffset(3, descriptionOffset.Value, 0); }
  public static void AddBuffers(FlatBufferBuilder builder, VectorOffset buffersOffset) { builder.AddOffset(4, buffersOffset.Value, 0); }
  public static VectorOffset CreateBuffersVector(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.Buffer>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateBuffersVectorBlock(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.Buffer>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBuffersVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Unity.InferenceEngine.Editor.LiteRT.Buffer>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBuffersVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Unity.InferenceEngine.Editor.LiteRT.Buffer>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartBuffersVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddMetadataBuffer(FlatBufferBuilder builder, VectorOffset metadataBufferOffset) { builder.AddOffset(5, metadataBufferOffset.Value, 0); }
  public static VectorOffset CreateMetadataBufferVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateMetadataBufferVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMetadataBufferVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMetadataBufferVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartMetadataBufferVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddMetadata(FlatBufferBuilder builder, VectorOffset metadataOffset) { builder.AddOffset(6, metadataOffset.Value, 0); }
  public static VectorOffset CreateMetadataVector(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.Metadata>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateMetadataVectorBlock(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.Metadata>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMetadataVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Unity.InferenceEngine.Editor.LiteRT.Metadata>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMetadataVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Unity.InferenceEngine.Editor.LiteRT.Metadata>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartMetadataVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSignatureDefs(FlatBufferBuilder builder, VectorOffset signatureDefsOffset) { builder.AddOffset(7, signatureDefsOffset.Value, 0); }
  public static VectorOffset CreateSignatureDefsVector(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.SignatureDef>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSignatureDefsVectorBlock(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.SignatureDef>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSignatureDefsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Unity.InferenceEngine.Editor.LiteRT.SignatureDef>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSignatureDefsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Unity.InferenceEngine.Editor.LiteRT.SignatureDef>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSignatureDefsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Unity.InferenceEngine.Editor.LiteRT.Model> EndModel(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Unity.InferenceEngine.Editor.LiteRT.Model>(o);
  }
  public static void FinishModelBuffer(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.Model> offset) { builder.Finish(offset.Value, "TFL3"); }
  public static void FinishSizePrefixedModelBuffer(FlatBufferBuilder builder, Offset<Unity.InferenceEngine.Editor.LiteRT.Model> offset) { builder.FinishSizePrefixed(offset.Value, "TFL3"); }
}


static class ModelVerify
{
  static public bool Verify(Unity.InferenceEngine.Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Version*/, 4 /*uint*/, 4, false)
      && verifier.VerifyVectorOfTables(tablePos, 6 /*OperatorCodes*/, Unity.InferenceEngine.Editor.LiteRT.OperatorCodeVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 8 /*Subgraphs*/, Unity.InferenceEngine.Editor.LiteRT.SubGraphVerify.Verify, false)
      && verifier.VerifyString(tablePos, 10 /*Description*/, false)
      && verifier.VerifyVectorOfTables(tablePos, 12 /*Buffers*/, Unity.InferenceEngine.Editor.LiteRT.BufferVerify.Verify, false)
      && verifier.VerifyVectorOfData(tablePos, 14 /*MetadataBuffer*/, 4 /*int*/, false)
      && verifier.VerifyVectorOfTables(tablePos, 16 /*Metadata*/, Unity.InferenceEngine.Editor.LiteRT.MetadataVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 18 /*SignatureDefs*/, Unity.InferenceEngine.Editor.LiteRT.SignatureDefVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}

}
